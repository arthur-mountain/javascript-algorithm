---
title: "542. 01 Matrix"
tags:
  - Array
  - Dynamic Programming
  - Breadth-First Search
  - Matrix
difficulty: "Medium"
date_solved: "2025-11-23"
link: "https://leetcode.com/problems/01-matrix/description/"
---

## 問題描述

給定一個 m x n 的 binary matrix，回傳每個 cell 到最近的 0 的距離。

兩個相鄰 cell 之間的距離為 1。

## Constraints

- m == mat.length
- n == mat\[i\].length
- 1 <= m, n <= 10\*\*4
- 1 <= m \* n <= 10\*\*4
- mat\[i\]\[j\] is either 0 or 1.
- There is at least one 0 in mat.

## 解題思路

### 初步分析(觀察與發想)

- 最短距離問題可以使用 BFS 解決，針對每個值為 1 的 cell 進行處理，值為 0 的 cell 距離本身就是 0，無需處理

- 每個 cell 到最近的零的距離，理論上可以透過「已處理過的鄰居 cell」來推導,因此也能使用 DP 解決

  - 當前 cell 到最近零的距離 = 四個方向(上下左右)已處理過的鄰居中的最小值 + 1

## 解法總覽

### Solution1(BFS，從每個 1 出發) - ❌ 會超時

- **思路說明**：

  遍歷整個 binary matrix，當遇到值為 1 的 cell 時，從該位置啟動 BFS 流程來尋找最近的 0。

  **BFS 流程：**

  初始化階段：

  - `min` 變數：記錄當前搜尋的層級深度，代表到起點的距離
  - `queue` 佇列：存放當前層所有待探索的 cell 座標 (row, col)
  - `visited` 集合：記錄已訪問過的格子，避免重複探索

  執行流程：

  1. 將起始位置 (startRow, startCol) 放入 queue
  2. 當 queue 非空時：

     - 取出當前層的所有 cell（記錄當前層大小，逐一處理）
     - 對當前層的每個 cell：
       - 檢查是否越界或已訪問過，若是則跳過
       - 標記為已訪問
       - 判斷當前 cell 是否為 0：
         - 若是 0，更新起始 cell 的距離為 `min`，並結束此次 BFS
         - 若不是 0，將四個方向的鄰居加入 queue（上、右、下、左）
     - 當前層處理完畢後，將 `min` 加 1，進入下一層的 BFS

- **複雜度分析**：

  - 時間複雜度：O((m × n)²) → 最壞情況下，每個 cell 的 BFS 都可能遍歷整個矩陣

  - 空間複雜度：O(m × n) → queue 和 visited set 的最大空間佔用

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 當前實作從每個 1 開始尋找最近的 0，存在大量重複的路徑探索，導致 Time Limit Exceeded

    - 例如：多個 1 可能會重複探索相同的中間路徑，造成計算浪費

- **測試案例**：

  - 案例 A：基本情況

    Input: mat=\[\[0,0,0\], \[0,1,0\], \[0,0,0\]\]

    Output: \[\[0,0,0\], \[0,1,0\], \[0,0,0\]\]

    Expected: \[\[0,0,0\], \[0,1,0\], \[0,0,0\]\]

    Explain: 中間的 1 被四周的 0 包圍，距離最近的 0 只有 1 步

  ***

  - 案例 B：多個 1 的情況

    Input: mat=\[\[0,0,0\], \[0,1,0\], \[1,1,1\]\]

    Output: \[\[0,0,0\], \[0,1,0\], \[1,2,1\]\]

    Expected: \[\[0,0,0\], \[0,1,0\], \[1,2,1\]\]

    Explain:

    - mat\[1\]\[1\] = 1：上下左右都有 0，距離為 1
    - mat\[2\]\[0\] = 1：左邊和上方有 0，距離為 1
    - mat\[2\]\[1\] = 2：最近的 0 在 mat\[0\]\[1\] 或 mat\[1\]\[0\]，需要走 2 步
    - mat\[2\]\[2\] = 1：右邊和上方有 0，距離為 1

  ***

  - 案例 C：前面都是 1，後面幾個才是 0

    Input: mat=\[\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[1,1,1\],\[0,0,0\]\]

    Output: Fatal Error: Javascript heap out of memory

    Expected: \[\[19,19,19\],\[18,18,18\],\[17,17,17\],\[16,16,16\],\[15,15,15\],\[14,14,14\],\[13,13,13\],\[12,12,12\],\[11,11,11\],\[10,10,10\],\[9,9,9\],\[8,8,8\],\[7,7,7\],\[6,6,6\],\[5,5,5\],\[4,4,4\],\[3,3,3\],\[2,2,2\],\[1,1,1\],\[0,0,0\]\]

### Solution2(多源 BFS，分層處理) - ✅ AC

- **思路說明**：

  Solution1 從每個 1 出發尋找最近的 0，導致重複路徑探索而 TLE。

  **核心思路轉換：**

  從 0 出發向外擴散尋找 1，同樣可以計算最短距離，且每個 cell 只需被訪問一次。

  **初始化階段：**

  - `distance` 變數：記錄當前從 0 開始向外擴散的距離（層級深度）
  - `queue` 佇列：存放當前層所有待探索的 cell 座標 (row, col)
  - `visited` 集合：記錄已訪問過的格子，避免重複探索

  **前置處理：**

  遍歷整個 binary matrix，將所有值為 0 的位置作為多源起點，全部放進 queue 中，並標記為已訪問

  **BFS 流程：**

  - 當 queue 非空時：

    - 遍歷當前層的所有 cell（記錄當前層大小，逐一處理）

      - 對當前 cell 的四個方向鄰居（上、右、下、左）進行檢查：

        - 若鄰居越界或已訪問過，則跳過

        - 若鄰居未被訪問過：
          - 更新鄰居的距離為 `distance + 1`（代表從最近的 0 到該鄰居的最短距離）
          - 將鄰居標記為已訪問
          - 將鄰居加入 queue，用於下一輪 BFS 繼續向外擴散

    - 當前層處理完畢後，將 `distance` 加 1，進入下一層的 BFS

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 僅被訪問一次

  - 空間複雜度：O(m × n) → queue 和 visited set 的最大空間佔用

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 是否可以直接在 mat 上標記已訪問，省去 visited set，使空間複雜度優化至 O(1)（僅考慮輸出空間）

- **測試案例**：同 Solution1 測試範例

### Solution2-1(多源 BFS，距離存於 queue) - ✅ AC

- **思路說明**：

  概念上同 Solution2，另一種多源 BFS 的實作方式，看起來比較直覺。

  **核心差異：**

  - Solution2 是按層級處理（使用外部 `distance` 變數記錄層級深度）

  - Solution2-1 則是將距離資訊直接存在 queue 的每個元素中，逐個從 queue 取出處理。

  **初始化階段：**

  - `queue` 佇列：存放待探索的 cell 資訊，格式為 \[row, col, distance\]

  - `visited` 二維陣列：記錄已訪問過的格子，避免重複探索

  **前置處理：**

  遍歷整個 binary matrix，將所有值為 0 的位置作為多源起點，以 \[row, col, 0\] 的格式放進 queue 中，並在 visited 陣列中標記為已訪問

  **BFS 流程：**

  - 當 queue 非空時：

    - 從 queue 中取出一個元素 \[row, col, distance\]
    - 更新 mat\[row\]\[col\] = distance（直接將計算出的距離寫入結果矩陣）
    - 對當前位置的四個方向鄰居（上、右、下、左）進行檢查：

      - 若鄰居越界或已訪問過，則跳過
      - 若鄰居未被訪問過：
        - 在 visited 陣列中標記為已訪問
        - 將鄰居以 \[nr, nc, distance + 1\] 的格式加入 queue（距離加 1 表示從當前位置往外擴散一步）

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 僅被訪問一次，每個 cell 在被標記為已訪問後不會再被加入 queue

  - 空間複雜度：O(m × n) → queue 的最大空間佔用（最壞情況下所有 cell 都在 queue 中）+ visited 二維陣列的空間佔用

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 相較於 Solution2 的分層處理，這種實作方式將距離資訊封裝在 queue 元素中，程式邏輯更為直觀，不需要額外的變數來追蹤當前層級深度

  - 使用二維陣列 `visited` 而非 Set，存取速度更快（O(1) 的陣列索引 vs Set 的雜湊查找）

- **測試案例**：同 Solution1 測試範例

### Solution3(DP) - WIP

- **思路說明**：

  WIP 待實作

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 至少被訪為一到兩次

  - 空間複雜度：O(1) → 直接修改原陣列，基於已經處理過的 cell 計算出當前 cell 最近的 0 的距離

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 如果只從單一方向遍歷「左上 -> 右下」、「右下 -> 左上」，一定會有一邊的資訊還沒處理，導致錯過可能的最短路徑

    - 如果是 「左上 -> 右下」，「右、下」cell 尚未被處理，變成只用「左、上」以處理過的 cell 計算，可能會漏掉「右、下」的最短路徑

    - 如果是 「右下 -> 左上」，「左、上」cell 尚未被處理，變成只用「右、下」以處理過的 cell 計算，可能會漏掉「左、上」的最短路徑

- **測試案例**：同 Solution1 測試範例

## 學習記錄

- 首次解題(多源 BFS)：2025-11-23 | 耗時：不紀錄(重理解思路) | 獨立完成：否。只有寫出 Solution1(BFS) 但會超時，第一次理解多源 BFS 的概念
- 複習1：<!-- 日期 --> | 耗時：分鐘 | 獨立完成：☐ 是 ☐ 否 | 順暢度：☐ 流暢 ☐ 卡頓 ☐ 忘記
