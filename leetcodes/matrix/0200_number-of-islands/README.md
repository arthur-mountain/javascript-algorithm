---
title: "200. Number of Islands"
tags:
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Union Find
  - Matrix
difficulty: "Medium"
date_solved: "2025-11-05"
link: "https://leetcode.com/problems/number-of-islands/description/"
---

## 問題描述

給定一個二維 binary 陣列 m x n grid，1 代表 land；0 代表 water，返回 islands 的總數。

island 的定義為：相鄰的水平 land 和垂直 land 被 water 包圍稱作一個 island

## Constraints

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 300
- grid[i][j] is '0' or '1'.

## 解題思路

### 初步分析(觀察與發想)

- 從一個 cell 開始遍歷時，盡可能延展自己四個方向的位置，如果是 1 則標記為 0 算作在同一座 island，直到四個方向都遇到 0 無法延展為止，此時 islands 數量 + 1。再接續進行下一個 cell 的遍歷，以此類推。

  - 要從一個 cell 往四個方向遍歷，可以透過四個迴圈或者直接使用 DFS recursion

## 解法總覽

### Solution1(DFS)

- **思路說明**：

  建立 helper function，往四個方向延展，並把遇到的 land 都標記成 water，因為當作同一座 island。邊界要注意、遇到 0 要停止。

  遍歷 grid 的每一個 cell，若當前 cell 為 land 時呼叫 helper function，延展當前 cell 的四個方向（若有遇到相鄰的 land，都算作同一座 island，所以標記為 0，後續再繼續遍歷 cell 時遇到 water 就不會重複計算 island），結束後將當前的 islands 總數加一。

  繼續遍歷下一個 cell 直到 grid 遍歷完畢，即可回傳 islands 總數

- **複雜度分析**：

  - 時間複雜度：O(m x n) -> 雖然有使用遞迴，但每一個 cell 最多只被訪問一次

  - 空間複雜度：O(m x n) -> 遞迴深度，如果整個 grid 都是 1 就會遞迴整個 grid

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 改用 BFS 解？

- **測試案例**：

  - 案例 A: 1 個 island

    Input: grid = [
    ["1","1","1","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","0","0"]
    ]

    Output: 1

    Expected: 1

  ***

  - 案例 B: 多個 islands

    Input: grid = [
    ["1","1","0","1","0"],
    ["1","1","0","1","0"],
    ["1","1","0","0","0"],
    ["0","0","0","1","0"]
    ]

    Output: 3

    Expected: 3

  ***

  - 案例 C: 整個 grid 都是 0

    Input: grid = [
    ["0","0","0","0","0"],
    ["0","0","0","0","0"],
    ["0","0","0","0","0"],
    ["0","0","0","0","0"]
    ]

    Output: 0

    Expected: 0

  ***

  - 案例 D: 整個 grid 都是 1

    Input: grid = [
    ["1","1","1","1","1"],
    ["1","1","1","1","1"],
    ["1","1","1","1","1"],
    ["1","1","1","1","1"]
    ]

    Output: 1

    Expected: 1

### Solution2(BFS)

- **思路說明**：

  遍歷 grid 的每一個 cell，當遍歷到 land 時，進入 BFS 流程。將當前 land 立即標記為 '0' 並放進 queue。

  當 queue 有值時，dequeue 取出 cell，檢查其四個方向的相鄰位置。

  若相鄰 cell 為 land，則先標記為 '0' 再放進 queue(先標記可避免同一個 cell 被重複加入 queue)。

  重複上述流程直到 queue 為空，代表此次 BFS 流程結束，當前 island 遍歷完畢，islands 總數加一。

  繼續遍歷下一個 cell，直到整個 grid 遍歷結束後回傳 islands 總數。

- **複雜度分析**：

  - 時間複雜度：O(m x n) -> 每一個 cell 最多只被訪問一次

  - 空間複雜度：O(min(m, n)) -> BFS 是層層往外擴散，queue 中最多會同時存在一整層的 cell。在最壞情況下(整個 grid 都是 1)，當 BFS 擴散到對角線附近時 queue 會達到最大長度，約為 min(m, n)

  - 通過狀態：✅ AC

- **測試案例**： 同 solution1 測試案例

### Solution3(Union Find)

- **核心概念**：

  1. **為什麼這題可以用 Union Find？**

     「Number of Islands」是典型的「連通分量」問題。當題目需要：

     - 判斷元素之間是否相連
     - 統計有多少個獨立的群組
     - 動態合併群組

     就可以考慮使用 Union Find。

  2. **從問題本質出發：什麼是一個島嶼？**

     - 一群相鄰的陸地
     - 換句話說：一群「連通」的陸地
     - 再換句話說：一個「連通分量」

     這正是 Union Find 最擅長處理的問題類型。

  3. **Union Find 心智模型**

     Union Find 是管理「分組關係」的工具，能回答三個核心問題：

     - x 和 y 在同一組嗎？ → `find(x) === find(y)`
     - 有幾個組？ → `count`
     - 把 x 和 y 合併成一組 → `union(x, y)`

  4. **相比 DFS/BFS 的優勢**

     - DFS/BFS 需要修改原始陣列（標記已訪問的陸地）
     - Union Find 不需修改原始資料，只維護額外的 parent 結構
     - Union Find 在需要「動態查詢連通性」的場景下特別高效（例如：題目變形為動態增加陸地時）

- **思路說明**：

  **初始化階段**：

  - `parent` 陣列：儲存每個陸地的父節點（同一座島嶼的節點會指向同一個根）
  - `rank` 陣列：紀錄以 i 為根的樹高度，用於合併時的優化（按秩合併）
  - `count`：紀錄目前有幾個獨立集合（島嶼數量）
  - 將每一座陸地的根設為自己，每一座陸地初始都是獨立島嶼

  **find 操作 (查找根節點)**：

  - 找到當前陸地所屬集合的根節點
  - 同時進行「路徑壓縮」優化：將路徑上的所有節點直接連接到根節點，使後續查找達到 O(1) 效率

  **union 操作 (合併集合)**：

  - 透過 find 找到兩個陸地的根節點，判斷是否已在同一集合
  - 若在同一集合：不需合併
  - 若在不同集合：需要合併
    - 使用「按秩合併」：將矮樹的根接到高樹的根下，保持樹平衡，避免退化成鏈表
    - 若高度相同：隨機選一個作為根，並將其高度加一
  - 合併後 count 減一（兩個島嶼變成一個）

  **遍歷階段**：

  - 遍歷 grid 的每個格子
  - 當遇到陸地時，檢查其右方和下方的鄰居（只檢查右、下可避免重複檢查，因為左、上已在之前的迭代中處理過）
  - 若鄰居也是陸地，執行 union 操作將它們合併為同一座島嶼
  - 將二維座標 `(i, j)` 轉換為一維索引：`id = i * n + j`

  最後返回 count，即為島嶼總數。

- **複雜度分析**：

  - 時間複雜度：O(m × n × α(m × n)) ≈ O(m × n)
    其中 α 是 Ackermann 函數的反函數，增長極其緩慢（在實際應用中可視為常數）。每個 cell 最多只被訪問一次。

  - 空間複雜度：O(m × n)
    需要 parent 和 rank 兩個陣列來維護 Union Find 結構。

  - 通過狀態：✅ AC

- **其他備註**：

  - **Union Find 的典型應用場景**：

    - 判斷圖中的連通分量數量（如本題）
    - 動態連通性問題（Kruskal 最小生成樹）
    - 朋友圈問題（LeetCode 547）
    - 冗餘連接（LeetCode 684, 685）

  - **為什麼這題三種解法都可行？**

    - DFS/BFS：直觀，適合「一次性遍歷」找出所有島嶼
    - Union Find：適合「需要頻繁查詢連通性」或「動態增刪陸地」的變形題

- **測試案例**： 同 solution1 測試案例

## 學習記錄

- 首次解題：2025-11-05 | 耗時：29分鐘 | 獨立完成：是
- 複習1：2025-11-06 | 耗時：7分鐘(2分鐘釐清題目、2分鐘思考實作DFS解、3分鐘實作) | 獨立完成：是 | 順暢度：流暢
- 複習2：2025-11-09 | 耗時：6分鐘(邊講後實作DFS) | 獨立完成：是 | 順暢度：流暢
- 複習3：2025-11-16 | 耗時：30分鐘(邊講後實作UnionFind) | 獨立完成：否 | 順暢度：卡頓。刻意練習 UnionFind，70%左右流暢，概念是理解得，像是 UnionFind constructor、findRoot 和 union 等實作大部分都有寫出來但實作過程有點像硬背，待複習
- 複習4：2025-11-19 | 耗時：11分鐘(BFS) | 獨立完成：是 | 順暢度：流暢。整體流程，中間在mark land to water 的地方寫錯有卡住一下，最後有自己找出問題
