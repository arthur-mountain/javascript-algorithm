---
title: "1254. Number of Closed Islands"
tags:
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Union Find
  - Matrix
difficulty: "Medium"
date_solved: "2025-12-21"
link: "https://leetcode.com/problems/number-of-closed-islands/description/"
---

## 問題描述

給予一個 2D grid，包含陸地(0)和水域(1)，返回封閉島嶼的數量。

**封閉島嶼定義**:
由水平或垂直方向相鄰的陸地(0)組成的連通區域，且該區域的四周完全被水域(1)包圍（即不與 grid 邊界接觸）。

## Constraints

- 2 <= grid.length, grid[0].length <= 100
- 0 <= grid[i][j] <= 1

## 解題思路

### 初步分析(觀察與發想)

- 這是連通性問題 + 計數問題，且邊界具有特殊意義：一旦島嶼與邊界相鄰，就不算封閉

- 核心策略：遍歷所有陸地，對每個未訪問的陸地啟動 DFS，探索整個島嶼並判斷是否觸及邊界

- DFS/BFS/Union-Find 都可解決這類連通性問題

## 解法總覽

### Solution 1 (DFS - 單次遍歷)

- **思路說明**：

  遍歷整個 2D grid，當遇到陸地(0)時進入 DFS 流程，DFS 回傳布林值表示「從這個格子出發的探索是否封閉」。

  **DFS 流程**：

  1. **越界或水域** → 回傳 `true`
     這個方向已經碰到邊界外或水域，代表這個方向是「安全的」（被水包圍）

  2. **位於 grid 邊界上的陸地** → 回傳 `false`
     此時格子一定是陸地（水域在步驟 1 已處理），而邊界上的陸地代表這個島嶼不封閉

  3. **內部陸地** → 標記為已訪問，繼續探索四個方向
     - 標記當前格子為 `1`（水域），一方面表示同一島嶼的陸地正在被計算，另一方面避免重複遍歷
     - 對上、右、下、左四個方向遞迴呼叫 DFS
     - 回傳四個方向的結果做 AND 運算

  **⚠️ 關鍵陷阱：短路求值**

  四個方向的 DFS 必須全部執行，不能讓短路求值中斷後續遍歷。

  原因是：即使某個方向已經確定不封閉，其他方向的陸地仍需被標記為已訪問，否則後續遍歷會重複計算同一個島嶼。

  ```javascript
  // ✅ 正確：先執行所有 DFS，再做 AND 運算
  grid[row][col] = 1;
  const up = dfs(row - 1, col);
  const right = dfs(row, col + 1);
  const bottom = dfs(row + 1, col);
  const left = dfs(row, col - 1);

  return up && right && bottom && left;
  ```

  ```javascript
  // ❌ 錯誤：短路求值會導致後續 DFS 不執行
  grid[row][col] = 1;
  return (
    dfs(row - 1, col) &&
    dfs(row, col + 1) &&
    dfs(row + 1, col) &&
    dfs(row, col - 1)
  );
  // 若第一個 dfs 回傳 false，後面三個方向根本不會被探索，
  // 導致那些陸地未被標記，之後會被誤判為新的島嶼
  ```

- **複雜度分析**：

  - 時間複雜度：O(m × n)，每個格子最多訪問一次

  - 空間複雜度：O(m × n)，最壞情況下遞迴深度為整個 grid（全是陸地時）

  - 通過狀態：✅ AC

- **測試案例**：

  - 案例 A：最小 grid 尺寸（2×2）— 無法形成封閉島嶼

    Input: `[[0,0],[0,0]]`

    Output: `0`

    Explain: 2×2 是 constraints 允許的最小尺寸，每個格子都在邊界上，不可能存在封閉島嶼

  ***

  - 案例 B：最小 grid 能形成封閉島嶼（3×3）

    Input: `[[1,1,1],[1,0,1],[1,1,1]]`

    Output: `1`

    Explain: 能形成封閉島嶼的最小 grid，只有正中央 (1,1) 是陸地且被水域完全包圍

  ***

  - 案例 C：全陸地 — 邊界汙染整個連通區域

    Input: `[[0,0,0],[0,0,0],[0,0,0]]`

    Output: `0`

    Explain: 所有格子形成一個連通區域，因為邊界格子也是陸地，整個區域都不算封閉

  ***

  - 案例 D：全水域 — 無島嶼

    Input: `[[1,1,1],[1,1,1],[1,1,1]]`

    Output: `0`

    Explain: 沒有任何陸地，測試迴圈是否正確跳過水域格子

  ***

  - 案例 E：邊界全陸地，內部有封閉島嶼

    Input: `[[0,0,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[0,1,1,1,0],[0,0,0,0,0]]`

    Output: `1`

    Explain: 邊界形成一圈陸地（不封閉），但內部 (2,2) 被水域包圍形成封閉島嶼，測試內外隔離判斷

  ***

  - 案例 F：多個獨立封閉島嶼 — 計數正確性

    Input: `[[1,1,1,1,1,1,1],[1,0,1,1,1,0,1],[1,1,1,1,1,1,1],[1,1,1,0,1,1,1],[1,1,1,1,1,1,1]]`

    Output: `3`

    Explain: 三個獨立的單格封閉島嶼，測試計數邏輯是否正確累加

  ***

  - 案例 G：L 形島嶼部分觸及邊界 — 連通區域整體判定

    Input: `[[0,1,1,1],[0,1,0,1],[1,1,1,1]]`

    Output: `1`

    Explain: 左側 (0,0) 和 (1,0) 形成連通區域，因 (0,0) 在邊界故不封閉；中間 (1,2) 是唯一封閉島嶼

  ***

  - 案例 H：複雜形狀封閉島嶼 — DFS 完整遍歷

    Input: `[[1,1,1,1,1,1],[1,0,0,0,0,1],[1,0,1,1,0,1],[1,0,0,0,0,1],[1,1,1,1,1,1]]`

    Output: `1`

    Explain: 內部形成 U 形連通陸地區域，應被視為一個封閉島嶼，測試 DFS 是否正確遍歷複雜形狀

  ***

  - 案例 I：角落陸地 — 四角特殊處理

    Input: `[[0,1,0],[1,1,1],[0,1,0]]`

    Output: `0`

    Explain: 四個角落都是邊界陸地，中間是水域，沒有封閉島嶼，測試角落是否被正確識別為邊界

  ***

  - 案例 J：細長 grid — 邊界佔比極高

    Input: `[[1,1,1,1,1,1,1,1,1,1],[1,0,0,0,1,1,0,0,0,1],[1,1,1,1,1,1,1,1,1,1]]`

    Output: `2`

    Explain: 3×10 細長 grid，中間行有兩個獨立連通區域，測試高度受限時的多島嶼識別

  ***

  - 案例 K：封閉島嶼緊鄰非封閉島嶼 — 邊界判定隔離

    Input: `[[0,1,1,1,1],[0,1,0,0,1],[1,1,0,0,1],[1,1,1,1,1]]`

    Output: `1`

    Explain: 左上角是邊界陸地（不封閉），中間 2×2 區域是封閉島嶼，測試相鄰但不連通的島嶼獨立判定

  ***

  - 案例 L：短路求值陷阱驗證

    Input: `[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,0],[1,1,1,1,1]]`

    Output: `0`

    Explain: 內部看似封閉但 (3,4) 是邊界陸地且與內部相連，專門測試避免短路求值的邏輯是否正確

## 學習記錄

- 首次解題(DFS - 單次遍歷)：2025-12-21 | 耗時：不紀錄(重理解思路) | 獨立完成：否
- 複習1：<!-- 日期 --> | 耗時：分鐘 | 獨立完成：□ 是 □ 否 | 順暢度：□ 流暢 □ 卡頓 □ 忘記
