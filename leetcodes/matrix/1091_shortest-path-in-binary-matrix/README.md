---
title: "1091. Shortest Path in Binary Matrix"
tags:
  - Array
  - Breadth-First Search
  - Matrix
difficulty: "Medium"
date_solved: "2025-11-29"
link: "https://leetcode.com/problems/shortest-path-in-binary-matrix/description/"
---

## 問題描述

給予一個 n \* n binary matrix，回傳最短路徑的 clear path，如果不存在則返回 -1

Clear path 的定義：從左上到右下的路徑中，節點皆為 0 的最短路徑，可以走八個方向(上下左右加斜線)

## Constraints

- n == grid.length
- n == grid\[i\].length
- 1 <= n <= 100
- grid\[i\]\[j\] is 0 or 1

## 解題思路

### 初步分析(觀察與發想)

- 用 BFS 找最短路徑，從左上角開始，如果「起點」、「終點」為 1 時就不存在 clear path，可以回傳 -1

  - 因為是從左上角開始找最短路徑，因此 BFS 單源作為起點

  - 初步複雜度分析：時間複雜度：O(n^2) 空間複雜度：O(n^2)

- Backtracking 加剪枝，這樣相當於 DFS，

  第一次仍需要走到底，紀錄到終點的路徑，後面才有辦法針對最短路徑去更新與剪枝、遇到 1 剪枝

## 解法總覽

### Solution1 - BFS

- **思路說明**：

  先檢查起點和終點是否為 1，，如果是則不存在 Clear Path 直接返回 -1

  **初始化：**

  - queue，以「第一個格子的座標」+「走到當前節點的路徑長度」作為起點

  - NEIGHBOR_DIRECTIONS: 八個方向的偏移座標，用於後續遍歷使用。

  - visited，紀錄已經拜訪過的路徑

    - 若當一個節點先被訪問，那麼從這個節點到終點的路徑一定是最短的，

      所以即使後續若仍需要經過這個節點就可以安心被跳過。可以想像一下，

      假設從節點A到終點的距離是 X，如果我在第三層跟第五層都需要經過這個節點才能到終點

      那麼不管怎麼樣 3 + X 一定小於 5 + X，所以外層(第五層)可以安心得跳過從**這個節點到終點的可能性**

  **BFS流程：**

  - 如果 queue 不為空，取出當前節點座標、走到當前節點的路徑長度

  - 如果當前節點座標是終點座標代表這條路徑一定是最短的，可以直接返回

  - 基於當前節點，遍歷 NEIGHBOR_DIRECTIONS，判斷當前節點的鄰居

    - 如果鄰居節點座標「越界」或「等於 1」就不符合 clear path 規定，直接 continue

    - 如果鄰居節點不曾訪問過

      - 把鄰居節點標記訪問過

      - 把「鄰居節點座標」、「走到鄰居節點的最短路徑」加進 queue 中，用於下一輪 BFS 流程，判斷其鄰居節點的鄰居，以此類推

      - P.S. 如果鄰居節點訪問過，那麼從這個節點往後走的路徑就可以不用考慮了，可以參考初始化 visited 時的描述

  最後 BFS 流程結束後，如果沒有任何抵達終點的 claer path，預設返回 -1。

- **複雜度分析**：

  - 時間複雜度：O(n \* n) -> 每個節點會需要被訪問一次

  - 空間複雜度：O(n \* n) -> queue 和 Set 最壞情況下可能會儲存全部格子

  - 通過狀態：✅ AC

- **其他備註\(優化方向、特殊限制、問題延伸討論\)**：

  - 若可以修改原陣列，可以不額外用 set

    - 直接把原陣列中拜訪過的 0 標註為 1，因為 1 本來就代表此路不通

- **測試案例**：

  - 案例 A: 起點為 1 不存在 clear path

    Input: grid=\[\[1,0,0\],\[1,1,0\],\[1,1,0\]\]

    Ouput: -1

    Expected: -1

    Explain: 當遇到起點為 1，不存在 clear path，同理終點為 1 也不存在 clear path，因此回傳 -1

  ***

  - 案例 B: 終點為 1 不存在 clear path

    Input: grid=\[\[1,0,0\],\[1,1,0\],\[1,1,0\]\]

    Ouput: -1

    Expected: -1

    Explain: 當遇到起點為 1，不存在 clear path，同理終點為 1 也不存在 clear path，因此回傳 -1

  ***

  - 案例 C: 當 n = 1 且值為 0 時，最短路徑就會是 1

    Input: grid=\[\[0\],\]

    Ouput: 1

    Expected: 1

  ***

  - 案例 D: 崎嶇路徑，需要先往回走才有辦法走到終點

    Input: grid=\[\[0,1,1,0,0,0\],\[0,1,0,1,1,0\],\[0,1,1,0,1,0\],\[0,0,0,1,1,0\],\[1,1,1,1,1,0\],\[1,1,1,1,1,0\]\]

    Ouput: 14

    Expected: 14

    Explain: 當在 (3, 2) 的時候，只能往右上(2,3) 走，但此時我必須往左上(1, 1)走，相當於往回走一格，才有辦法到終點

## 學習記錄

- 首次解題(BFS)：2025-11-29 | 耗時：不紀錄(重理解思路) | 獨立完成：否

- 複習1(BFS)：2025-11-30 | 耗時：8分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 核心概念都有理解，也能流暢的寫出來，但腦海模擬流程比較沒那麼順暢

- 複習2(BFS)：2025-12-03 | 耗時：10分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 小地方有問題，起點初始化時沒標記 visited，因為是要找到最右下角的最小距離，所以這邊仍然能 AC。

    但會有重複訪問的問題，仍建議要標記起點 visited

- 複習3(BFS)：2025-12-10 | 耗時：20分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 嘗試使用 datastruc-js Queue 但對 Queue methods 不熟所以卡比較久，但大方向的概念和實作很快就做出來了

- 複習4(BFS)：2026-01-09 | 耗時：12分鐘 | 獨立完成：是 | 順暢度：流暢。
