---
title: "130. Surrounded Regions"
tags:
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Union Find
  - Matrix
difficulty: "Medium"
date_solved: "2025-12-07"
link: "https://leetcode.com/problems/surrounded-regions/description/"
---

## 問題描述

給予一個 m x n board 只會有 'X' 和 'O' 兩種 letters，將 surrounded region in-place 將 'O' 替換成 'X'。

**Region 定義**：所有被 X 包圍起來的 O(包含水平、垂直方向連起來的範圍)，且 region 內的任一個 O 不能在邊界上。

## Constraints

- m == board.length
- n == board\[i\].length
- 1 <= m, n <= 200
- board\[i\]\[j\] is 'X' or 'O'.

## 解題思路

### 初步分析(觀察與發想)

- 使用 DFS，當遇到 'O' 的時候才進入 DFS 流程，
  收集 region cells，再判斷該 region 是否包含邊界上的 'O'，
  如果沒有則可以把該 region 範圍內的值都替換成 'X'。

  **關鍵觀察：**

  - Matrix 結構，水平垂直連接 → 適合 BFS / DFS
  - 涉及 capture region、連通性、區域性 → 可考慮 Union Find (?)
  - **邊界是特殊角色**：如果 region 包含邊界上的 cell(s) 則整個 region 都不合法
  - 要求 in-place 操作，不能建立新陣列

  **解題策略思考：**

  - 邊界上的 cell 都不考慮，且一旦連通到邊界上的 "O"，整個 region 就不合法

  - 正向思考：收集每個 region，判斷是否包含邊界
    - 收集完當前 region 後判斷要不要 replace
    - 這些 region cell 都是連通的，處理完不需要回朔，因此不需要 visited.delete
    - 從最外層往內一層開始遍歷

  **初步複雜度分析：**

  - 時間：O(m × n) → 每個元素被訪問常數次，因為被訪問過一次就不再訪問，不論是 'X' 或 'O'
  - 空間：O(m × n) → callstack + visited + region cells 都可能存 m × n 個元素

## 解法總覽

### Solution1 - DFS(正向思考)

- **思路說明**：

  遍歷 board 時，只需遍歷範圍 `1 ~ ROW - 1` 和 `1 ~ COL - 1`，因為邊界上的值不論是 'X' 或 'O' 都不用處理。

  當遇到 'O' 時，建立一個 regionCells 陣列用來收集這個連通區域的每一個 cell，然後進入 DFS 流程。

  **DFS 流程：**

  1. 判斷當前格子是否已 visited，如果訪問過就不重複訪問

  2. 將當前格子加入到 regionCells 和 visited 中，接著遍歷當前格子的四個鄰居遞迴 DFS
     - 只有當鄰居格子在合法邊界內且值為 'O' 時，才遞迴 DFS

  當 DFS 結束後，代表這輪連通的 regionCells 收集完畢。

  接著檢查 region 是否包含邊界上的 cell：

  - 如果沒有包含邊界 cell，則將這些 regionCells 的 'O' 都改成 'X'
  - 如果包含邊界 cell，則不處理

  繼續遍歷直到結束。

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 被訪問常數次，不論是 'O' 或 'X'，一旦被訪問就會被加進 visited 中，後續不再訪問

  - 空間複雜度：O(m × n) → callstack + visited + region cells 可能各存 m × n 個元素

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 目前使用的空間複雜度比較多，涉及到三個資料結構去收集。優化請見 Solution2

- **測試案例**：

  - 案例 A：中間的 region 要替換，但邊上的 "O" 不處理

    Input: board = \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","X","O","X"\],\["X","O","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","O","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","O","X","X"\]\]

  ***

  - 案例 B：只有一個 "X"，不用處理

    Input: board = \[\["X"\]\]

    Output: \[\["X"\]\]

    Expected: \[\["X"\]\]

  ***

  - 案例 C：只有一個 "O"，也不用處理，因為在邊上

    Input: board = \[\["O"\]\]

    Output: \[\["O"\]\]

    Expected: \[\["O"\]\]

  ***

  - 案例 D：因為 region 連到邊上了，所以整塊 region 不處理

    Input: board = \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

  ***

  - 案例 E：整個 board 都是 "O"，不但沒有被 "X" 包圍，整塊 region 包含邊上的 "O"，所以不處理

    Input: board = \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

    Output: \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

    Expected: \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

  ***

  - 案例 F：整個 board 都是 "X"，不用處理

    Input: board = \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

### Solution2 - DFS(反向思考)

- **思路說明**：

  Solution1 為正向思考，從每一個 'O' 出發找到連通區域，相較之下使用的空間比較多。

  此解法為反向思考，空間使用率降低，整體寫起來也比較乾淨。

  **核心邏輯：先標記例外(與邊界連通的 O)，再處理其餘**

  1. 先從邊界出發，進入 DFS 流程直接 in-place 對 board 進行標記

     **目的**：從邊界上的 'O' 出發，將任何與邊界 'O' 連通的 'O' 標記成 '#'

     **DFS 流程：**

     1. 若當前 indices 越界，或者格子等於 'X' 或 '#'，則不用訪問

        - 透過標記為 '#'，一方面代表該格子與邊界上的 'O' 連通，一方面也代表這個格子已訪問過，相當於 visited 的效果

        - 若格子是 'X' 也不用訪問，因為目的是找與邊界 'O' 連通的 'O'

     2. 將當前格子標記為 '#'，作為與邊界上的 'O' 連通的標記，在後續遍歷處理標記時會翻轉回 'O'

     3. 接著遍歷當前格子的四個鄰居，遞迴 DFS

     當 DFS 結束，代表整個 board 標記完成

  2. 再遍歷 board 處理標記和 region

     - 把標記成 '#' 的格子都還原成 'O'(這些是與邊界連通的，不能替換)

     - 把仍然為 'O' 的格子翻轉成 'X'(這些沒有與邊界連通，需要替換)

  最後回傳 board

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 常數次訪問

  - 空間複雜度：O(m × n) → callstack

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  **Pattern：正向 vs 反向思考**

  **何時考慮反向思考？**

  - 「例外」比「常規」少時(本題中，與邊界連通的 O 通常比被包圍的 O 少)

  - 邊界有特殊性質時(本題中，邊界是判斷的關鍵)

  - 空間複雜度可優化時(反向思考只需要原地標記，不需要額外收集)

  **反向思考的優勢：**

  - 不需要額外的 visited 和 regionCells 資料結構

  - 程式碼邏輯更清晰(兩階段：標記例外 → 處理其餘)

  - 與類似題目(如 LC 417, LC 1020)形成統一的解題模式

- **測試案例**：同 Solution1 測試案例

### Solution3 - 多源 BFS

- **思路說明**：

  **核心邏輯：** 先標記例外(與邊界連通的 O)，再處理其餘

  **目的：** 從邊界上的 'O' 出發，將任何與邊界 'O' 連通的 'O' 標記成 '#'

  **初始化階段：**

  將邊界上所有的 'O' 加入到 queue 中作為多源起點

  1. 遍歷上、下兩邊：檢查第一列和最後一列

  2. 遍歷左、右兩邊：檢查第一行和最後一行

  **BFS 流程：** 當 queue 非空時，逐一處理每個格子：

  1. 從 queue 中取出當前格子的座標 \[row, col\]

  2. 將當前格子標記為 '#'，這個標記有雙重意義：

     - 代表該格子與邊界上的 'O' 連通

     - 同時作為「已訪問」的標記，相當於 visited 的效果

  3. 遍歷當前格子的四個鄰居(上、右、下、左)，

     - 進行邊界與狀態檢查：

       - 若當前座標越界，則跳過

       - 若格子是 'X'，則跳過（目的是找與邊界 'O' 連通的 'O'）

       - 若格子已標記為 '#'，則跳過（代表已訪問過，避免重複處理）

     - 將鄰居座標加入 queue 中，待下一輪 BFS 繼續處理

  當 BFS 結束，代表整個 board 標記完成。

  **後處理階段：**

  遍歷整個 board 處理標記和 region：

  1. 將標記為 '#' 的格子還原成 'O'（這些是與邊界連通的，不能替換）

  2. 將仍然為 'O' 的格子翻轉成 'X'（這些沒有與邊界連通，需要替換）

  最後回傳 board

- **複雜度分析**：

  - 時間複雜度：O(m × n)

    - 初始化邊界：O(m + n)

    - BFS 過程：每個格子最多被訪問一次，因為標記為 '#' 後就不會再被處理 → O(m × n)

    - 後處理遍歷：O(m × n)

  - 空間複雜度：O(m × n) →

    - queue 的最大空間佔用：最壞情況下所有格子都是 'O'，所有格子都會進入 queue → O(m × n)

    - 不需要額外的 visited 資料結構，因為使用 '#' 標記達到相同效果

  - 通過狀態：✅ AC

- **測試案例**：同 Solution1 測試案例

### Solution4 - UnionFind

- **思路說明**：

  **核心概念：**

  UnionFind 擅長維護元素間的連通性關係。本題的關鍵在於：**與邊界 'O' 連通的格子不能被替換**。

  因此引入一個**虛擬根節點** `edgeIdOfO`(值為 `ROW * COL`，因為有效索引範圍是 `0` 到 `ROW * COL - 1`)，代表「邊界連通區域」。

  所有邊界上的 'O' 初始時直接指向這個虛擬根節點，這樣任何與邊界 'O' 連通的格子，其根節點最終都會是 `edgeIdOfO`。

  **演算法流程：**

  **階段 1：初始化 UnionFind**

  - 建立 `parent` 陣列（大小 `ROW * COL + 1`）：記錄每個格子的父節點

    - **關鍵設定**：`parent[edgeIdOfO] = edgeIdOfO`(虛擬根節點必須滿足「根節點指向自己」的規則)

    - 二維座標 `(row, col)` 映射為一維 ID：`row * COL + col`

    - 邊界上的 'O'：`parent[id] = edgeIdOfO`

    - 其他格子：`parent[id] = id`

  - 建立 `height` 陣列(大小 `ROW * COL + 1`)：記錄每棵樹的高度，用於按秩合併優化，統一初始化為 `1`

  **階段 2：建立連通關係**

  遍歷整個 board，對每個 'O' 格子：

  - 檢查**右邊**格子：如果也是 'O'，則執行 `union(當前ID, 右邊ID)`

  - 檢查**下邊**格子：如果也是 'O'，則執行 `union(當前ID, 下邊ID)`

  **優化技巧**：只需檢查「右」和「下」兩個方向，避免重複處理

  - 左、上方向在之前的迭代中已被處理（當時的「右」和「下」）

  - 這樣每對相鄰 'O' 格子只會執行一次 `union` 操作

  **階段 3：標記與替換**

  再次遍歷 board，對每個 'O' 格子：

  - 使用 `findRoot(id)` 找到其根節點

  - 若根節點**不是** `edgeIdOfO` → 未與邊界連通 → 翻轉成 'X'

  - 若根節點**是** `edgeIdOfO` → 與邊界連通 → 保持 'O'

  **UnionFind 核心操作詳解：**

  **1. `findRoot(id)`：路徑壓縮優化**

  ```javascript
  // 遞迴追溯到根節點，同時將路徑上所有節點直接指向根
  if (this.parent[id] === id) return this.parent[id];
  return (this.parent[id] = this.findRoot(this.parent[id]));
  ```

  - **作用**：降低樹的高度，加速後續查詢

  - **時間複雜度**：攤銷 O(α(n))，α 為反阿克曼函數，實際應用中 < 5

  **2. `union(id1, id2)`：按秩合併優化**

  ```javascript
  // 找到兩個節點的根
  const root1 = this.findRoot(id1);
  const root2 = this.findRoot(id2);

  // 將較矮的樹接到較高的樹下，平衡樹高
  if (height[root1] > height[root2]) {
    parent[root2] = root1;
  } else if (height[root1] < height[root2]) {
    parent[root1] = root2;
  } else {
    parent[root1] = root2;
    height[root2]++; // 高度相同時，新根的高度 +1
  }
  ```

  - **作用**：控制樹的高度，避免退化成鏈表

  - **關鍵**：更新的是**新根**的高度，而非被合併的節點

  **3. `isConnectedToEdgeO(id)`：連通性判斷**

  ```javascript
  // 必須使用 findRoot 追溯到真正的根節點
  return this.findRoot(id) === this.edgeIdOfO;
  ```

  - **為何不能直接用 `parent[id]`？**

    - 路徑壓縮是「惰性」的，只在調用 `findRoot()` 時觸發

    - 直接訪問 `parent[id]` 可能得到中間節點，而非根節點

    - 使用 `findRoot()` 確保追溯到真正的根，同時觸發路徑壓縮

  **虛擬根節點設計的關鍵細節：**

  - **為何 `parent` 陣列大小是 `ROW * COL + 1`？**

    - 索引 `0` 到 `ROW * COL - 1` 用於實際格子

    - 索引 `ROW * COL` 用於虛擬根節點 `edgeIdOfO`

    - 必須為虛擬節點分配空間，否則訪問 `parent[edgeIdOfO]` 會越界(undefined)

  - **為何需要 `parent[edgeIdOfO] = edgeIdOfO`？**

    - UnionFind 的核心鐵律：根節點必須滿足 `parent[root] = root`，所以一開始才初始化為 `ROW * COL + 1` 就是為了虛擬節點

    - 如果不設定，`findRoot(edgeIdOfO)` 會因 `parent[edgeIdOfO] = undefined` 而出錯

    - 進而導致遞迴傳入 `findRoot(undefined)`，返回錯誤結果

- **複雜度分析**：

  - **時間複雜度**：**O(m × n × α(m × n))**

    - 初始化：O(m × n)

    - 建立連通關係：每個格子最多進行 2 次 `union` 操作 → O(m × n × α(m × n))

    - 後處理遍歷：每個格子進行 1 次 `findRoot` 操作 → O(m × n × α(m × n))

    - α 是反阿克曼函數，實際應用中可視為常數（< 5）

  - **空間複雜度**：**O(m × n)**

    - `parent` 陣列：O(m × n + 1) ≈ O(m × n)

    - `height` 陣列：O(m × n + 1) ≈ O(m × n)

    - 遞迴呼叫堆疊：O(α(m × n)) ≈ O(1)

  - 通過狀態：✅ AC

- **其他備註（優化方向、特殊限制、問題延伸討論）**：

  - **UnionFind vs DFS/BFS 選擇：**

  | 特性           | UnionFind                  | DFS/BFS               |
  | -------------- | -------------------------- | --------------------- |
  | **適用場景**   | 多次查詢連通性、動態連接   | 單次遍歷、路徑搜尋    |
  | **時間複雜度** | O(m × n × α)               | O(m × n)              |
  | **空間複雜度** | O(m × n)                   | O(m × n)              |
  | **代碼複雜度** | 較高（需實現完整資料結構） | 較低（遞迴/迭代）     |
  | **本題推薦度** | ⭐⭐⭐ 學習價值高          | ⭐⭐⭐⭐⭐ 更簡潔高效 |

  > **本題中 DFS/BFS 更優**：因為只需單次遍歷判斷連通性，不涉及動態查詢或修改。

  - **UnionFind 經典應用場景：**

    - **動態連通性問題**：Kruskal 最小生成樹（LC 1584）
    - **區域合併**：LC 200. Number of Islands 變形（需要合併操作）
    - **社交網絡分析**：LC 547. Number of Provinces
    - **環檢測**：LC 684. Redundant Connection

  - **實作陷阱總結：**

    1. **虛擬根節點的完整設定**：

       - ❌ 只設定 `edgeIdOfO = ROW * COL`（不夠）
       - ✅ 必須設定 `parent[edgeIdOfO] = edgeIdOfO` (滿足根節點規則)

       - ✅ `parent` 陣列大小必須是 `ROW * COL + 1` (為虛擬節點分配空間)

    2. **連通性判斷必須用 findRoot()**：

       - ❌ `return this.parent[id] === edgeIdOfO` (可能得到中間節點)

       - ✅ `return this.findRoot(id) === edgeIdOfO` (確保追溯到根)

  - **Pattern：虛擬節點技巧**

    - **何時使用虛擬節點？**

      - 需要將多個元素統一視為「同一類」時

      - 邊界、特殊狀態需要特殊處理時

      - 簡化判斷邏輯 (本題中，不需要遍歷所有邊界格子，只需判斷根節點)

    - **虛擬節點設計要點：**

      - 選擇不與實際索引衝突的 ID (本題用 `ROW * COL`)

      - 必須滿足根節點的規則：`parent[virtual] = virtual`

      - 陣列大小要包含虛擬節點的空間

- **測試案例**：同 Solution1 測試案例

## 學習記錄

- 首次解題(DFS正向思考)：2025-12-07 | 耗時：不紀錄(重理解思路) | 獨立完成：是

- 首次解題(DFS反向思考)：2025-12-07 | 耗時：不紀錄(重理解思路) | 獨立完成：否

- 首次解題(多源BFS)：2025-12-13 | 耗時：不紀錄(重理解思路) | 獨立完成：是

- 首次解題(UnionFindBFS)：2025-12-13 | 耗時：不紀錄(重理解思路) | 獨立完成：否

- 複習1(DFS反向思考)：2025-12-08 | 耗時：13分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 花比較多時間再寫註解，而且感覺比較像是憑藉著印象照寫出來雖然有思考，而不是分析出什麼方式比較好。

  - 待複習：即使是有理解各種解法的細節，但在解題當下仍是以背解法解題，要改透過分析、思考的方式決定實作。

- 複習2(DFS反向思考)：2025-12-11 | 耗時：10分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 比較能思考出，正向思考可能遇到的問題(像是需要先收集完當前 region cells 才能判斷是否包含邊界上的 "O"，會需要比較多時間、空間去判斷這件事)，因此能從反向思考出發，但還是有點憑藉印象也出來就是了

- 複習3(多源BFS反向思考)：2025-12-18 | 耗時：15分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 有點太熟了，因此腦海是有解法的，但還是有把分析過程寫出來，所以花了一些時間
