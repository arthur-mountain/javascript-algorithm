---
title: "130. Surrounded Regions"
tags:
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Union Find
  - Matrix
difficulty: "Medium"
date_solved: "2025-12-07"
link: "https://leetcode.com/problems/surrounded-regions/description/"
---

## 問題描述

給予一個 m x n board 只會有 'X' 和 'O' 兩種 letters，將 surrounded region in-place 將 'O' 替換成 'X'。

**Region 定義**：所有被 X 包圍起來的 O(包含水平、垂直方向連起來的範圍)，且 region 內的任一個 O 不能在邊界上。

## Constraints

- m == board.length
- n == board\[i\].length
- 1 <= m, n <= 200
- board\[i\]\[j\] is 'X' or 'O'.

## 解題思路

### 初步分析(觀察與發想)

- 使用 DFS，當遇到 'O' 的時候才進入 DFS 流程，
  收集 region cells，再判斷該 region 是否包含邊界上的 'O'，
  如果沒有則可以把該 region 範圍內的值都替換成 'X'。

  **關鍵觀察：**

  - Matrix 結構，水平垂直連接 → 適合 BFS / DFS
  - 涉及 capture region、連通性、區域性 → 可考慮 Union Find (?)
  - **邊界是特殊角色**：如果 region 包含邊界上的 cell(s) 則整個 region 都不合法
  - 要求 in-place 操作，不能建立新陣列

  **解題策略思考：**

  - 邊界上的 cell 都不考慮，且一旦連通到邊界上的 "O"，整個 region 就不合法

  - 正向思考：收集每個 region，判斷是否包含邊界
    - 收集完當前 region 後判斷要不要 replace
    - 這些 region cell 都是連通的，處理完不需要回朔，因此不需要 visited.delete
    - 從最外層往內一層開始遍歷

  **初步複雜度分析：**

  - 時間：O(m × n) → 每個元素被訪問常數次，因為被訪問過一次就不再訪問，不論是 'X' 或 'O'
  - 空間：O(m × n) → callstack + visited + region cells 都可能存 m × n 個元素

## 解法總覽

### Solution1 - DFS(正向思考)

- **思路說明**：

  遍歷 board 時，只需遍歷範圍 `1 ~ ROW - 1` 和 `1 ~ COL - 1`，因為邊界上的值不論是 'X' 或 'O' 都不用處理。

  當遇到 'O' 時，建立一個 regionCells 陣列用來收集這個連通區域的每一個 cell，然後進入 DFS 流程。

  **DFS 流程：**

  1. 判斷當前格子是否已 visited，如果訪問過就不重複訪問

  2. 將當前格子加入到 regionCells 和 visited 中，接著遍歷當前格子的四個鄰居遞迴 DFS
     - 只有當鄰居格子在合法邊界內且值為 'O' 時，才遞迴 DFS

  當 DFS 結束後，代表這輪連通的 regionCells 收集完畢。

  接著檢查 region 是否包含邊界上的 cell：

  - 如果沒有包含邊界 cell，則將這些 regionCells 的 'O' 都改成 'X'
  - 如果包含邊界 cell，則不處理

  繼續遍歷直到結束。

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 被訪問常數次，不論是 'O' 或 'X'，一旦被訪問就會被加進 visited 中，後續不再訪問

  - 空間複雜度：O(m × n) → callstack + visited + region cells 可能各存 m × n 個元素

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 目前使用的空間複雜度比較多，涉及到三個資料結構去收集。優化請見 Solution2

- **測試案例**：

  - 案例 A：中間的 region 要替換，但邊上的 "O" 不處理

    Input: board = \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","X","O","X"\],\["X","O","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","O","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","O","X","X"\]\]

  ***

  - 案例 B：只有一個 "X"，不用處理

    Input: board = \[\["X"\]\]

    Output: \[\["X"\]\]

    Expected: \[\["X"\]\]

  ***

  - 案例 C：只有一個 "O"，也不用處理，因為在邊上

    Input: board = \[\["O"\]\]

    Output: \[\["O"\]\]

    Expected: \[\["O"\]\]

  ***

  - 案例 D：因為 region 連到邊上了，所以整塊 region 不處理

    Input: board = \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","O","O","X"\],\["X","O","O","X"\],\["X","O","X","X"\]\]

  ***

  - 案例 E：整個 board 都是 "O"，不但沒有被 "X" 包圍，整塊 region 包含邊上的 "O"，所以不處理

    Input: board = \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

    Output: \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

    Expected: \[\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\],\["O","O","O","O"\]\]

  ***

  - 案例 F：整個 board 都是 "X"，不用處理

    Input: board = \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

    Output: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

    Expected: \[\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\],\["X","X","X","X"\]\]

### Solution2 - DFS(反向思考)

- **思路說明**：

  Solution1 為正向思考，從每一個 'O' 出發找到連通區域，相較之下使用的空間比較多。

  此解法為反向思考，空間使用率降低，整體寫起來也比較乾淨。

  **核心邏輯：先標記例外(與邊界連通的 O)，再處理其餘**

  1. 先從邊界出發，進入 DFS 流程直接 in-place 對 board 進行標記

     **目的**：從邊界上的 'O' 出發，將任何與邊界 'O' 連通的 'O' 標記成 '#'

     **DFS 流程：**

     1. 若當前 indices 越界，或者格子等於 'X' 或 '#'，則不用訪問

        - 透過標記為 '#'，一方面代表該格子與邊界上的 'O' 連通，一方面也代表這個格子已訪問過，相當於 visited 的效果

        - 若格子是 'X' 也不用訪問，因為目的是找與邊界 'O' 連通的 'O'

     2. 將當前格子標記為 '#'，作為與邊界上的 'O' 連通的標記，在後續遍歷處理標記時會翻轉回 'O'

     3. 接著遍歷當前格子的四個鄰居，遞迴 DFS

     當 DFS 結束，代表整個 board 標記完成

  2. 再遍歷 board 處理標記和 region

     - 把標記成 '#' 的格子都還原成 'O'(這些是與邊界連通的，不能替換)

     - 把仍然為 'O' 的格子翻轉成 'X'(這些沒有與邊界連通，需要替換)

  最後回傳 board

- **複雜度分析**：

  - 時間複雜度：O(m × n) → 每個 cell 常數次訪問

  - 空間複雜度：O(m × n) → callstack

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  **Pattern：正向 vs 反向思考**

  **何時考慮反向思考？**

  - 「例外」比「常規」少時(本題中，與邊界連通的 O 通常比被包圍的 O 少)

  - 邊界有特殊性質時(本題中，邊界是判斷的關鍵)

  - 空間複雜度可優化時(反向思考只需要原地標記，不需要額外收集)

  **反向思考的優勢：**

  - 不需要額外的 visited 和 regionCells 資料結構

  - 程式碼邏輯更清晰(兩階段：標記例外 → 處理其餘)

  - 與類似題目(如 LC 417, LC 1020)形成統一的解題模式

- **測試案例**：同 Solution1 測試案例

### Solution3 - 多源 BFS

- **思路說明**：

  **核心邏輯：** 先標記例外(與邊界連通的 O)，再處理其餘

  **目的：** 從邊界上的 'O' 出發，將任何與邊界 'O' 連通的 'O' 標記成 '#'

  **初始化階段：**

  將邊界上所有的 'O' 加入到 queue 中作為多源起點

  1. 遍歷上、下兩邊：檢查第一列和最後一列

  2. 遍歷左、右兩邊：檢查第一行和最後一行

  **BFS 流程：** 當 queue 非空時，逐一處理每個格子：

  1. 從 queue 中取出當前格子的座標 \[row, col\]

  2. 將當前格子標記為 '#'，這個標記有雙重意義：

     - 代表該格子與邊界上的 'O' 連通

     - 同時作為「已訪問」的標記，相當於 visited 的效果

  3. 遍歷當前格子的四個鄰居(上、右、下、左)，

     - 進行邊界與狀態檢查：

       - 若當前座標越界，則跳過

       - 若格子是 'X'，則跳過（目的是找與邊界 'O' 連通的 'O'）

       - 若格子已標記為 '#'，則跳過（代表已訪問過，避免重複處理）

     - 將鄰居座標加入 queue 中，待下一輪 BFS 繼續處理

  當 BFS 結束，代表整個 board 標記完成。

  **後處理階段：**

  遍歷整個 board 處理標記和 region：

  1. 將標記為 '#' 的格子還原成 'O'（這些是與邊界連通的，不能替換）

  2. 將仍然為 'O' 的格子翻轉成 'X'（這些沒有與邊界連通，需要替換）

  最後回傳 board

- **複雜度分析**：

  - 時間複雜度：O(m × n)

    - 初始化邊界：O(m + n)

    - BFS 過程：每個格子最多被訪問一次，因為標記為 '#' 後就不會再被處理 → O(m × n)

    - 後處理遍歷：O(m × n)

  - 空間複雜度：O(m × n) →

    - queue 的最大空間佔用：最壞情況下所有格子都是 'O'，所有格子都會進入 queue → O(m × n)

    - 不需要額外的 visited 資料結構，因為使用 '#' 標記達到相同效果

  - 通過狀態：✅ AC

- **測試案例**：同 Solution1 測試案例

## 學習記錄

- 首次解題(DFS正向思考)：2025-12-07 | 耗時：不紀錄(重理解思路) | 獨立完成：是

- 首次解題(DFS反向思考)：2025-12-07 | 耗時：不紀錄(重理解思路) | 獨立完成：否

- 首次解題(多源BFS)：2025-12-13 | 耗時：不紀錄(重理解思路) | 獨立完成：是

- 複習1(DFS反向思考)：2025-12-08 | 耗時：13分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 花比較多時間再寫註解，而且感覺比較像是憑藉著印象照寫出來雖然有思考，而不是分析出什麼方式比較好。

  - 待複習：即使是有理解各種解法的細節，但在解題當下仍是以背解法解題，要改透過分析、思考的方式決定實作。

- 複習2(DFS反向思考)：2025-12-11 | 耗時：10分鐘 | 獨立完成：是 | 順暢度：流暢。

  - 比較能思考出，正向思考可能遇到的問題(像是需要先收集完當前 region cells 才能判斷是否包含邊界上的 "O"，會需要比較多時間、空間去判斷這件事)，因此能從反向思考出發，但還是有點憑藉印象也出來就是了
