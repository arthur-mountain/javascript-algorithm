---
title: "695. Max Area of Island"
tags:
  - Array
  - Depth-First Search
  - Breadth-First Search
  - Union Find
  - Matrix
difficulty: "Medium"
date_solved: "2025-11-16"
link: "https://leetcode.com/problems/max-area-of-island/description/"
---

## 問題描述

給定一個二維 binary 陣列 grid，

Island(島嶼)的定義：由 '1'(land/陸地) 組成，且四周(horizontal or vertical) 被 '0'(water/水域) 包圍，

回傳擁有最多陸地數量的島嶼面積

## Constraints

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 50
- grid[i][j] is either 0 or 1.

## 解題思路

### 初步分析(觀察與發想)

- 這題屬於靜態分析問題，不涉及增量或動態更新，可以直接透過 DFS/BFS 處理。當然也能用 UnionFind 處理，但 UnionFind 更擅長處理動態場景

  - 詳情參考 [200. numbers of island](../0200_number-of-islands/README.md)

- 在遍歷過程中需要記錄當前陸地的最大數量。在計算每個島嶼時，同步記錄該島嶼的陸地數量，當該島嶼處理完畢後，與當前最大值比較並更新

## 解法總覽

### Solution1(DFS)

- **思路說明**：

  遍歷整個 grid，當遇到陸地時進入 DFS 處理。在 DFS 中，先將陸地數量加一，再將當前陸地標記為水域('0')，避免重複計算。

  接著對當前陸地的四個方向(上右下左)進行 DFS 遍歷，直到超出邊界或遇到水域時停止。

  每處理完一個島嶼，就更新最大陸地數量。已處理過的陸地因為被標記為水域，在後續遍歷中會被跳過，不會重複計算。

  持續遍歷直到處理完所有 cell，最後回傳記錄到的最大陸地數量

- **複雜度分析**：

  - 時間複雜度：O(m × n) -> 每個 cell 最多被訪問常數次(外層 grid 遍歷一次 + DFS 內部可能再訪問一次)

  - 空間複雜度：O(m × n) -> DFS Call stack 深度，最壞情況發生在陸地呈蛇形排列時

  - 通過狀態：✅ AC

- **測試案例**：

  - 案例 A: 全是水域

    Input: grid = \[\[0,0,0,0,0,0,0,0\]\]

    Output: 0

    Expected: 0

  ***

  - 案例 B: 全是陸地

    Input: grid = \[\[1,1,1,1,1,1,1,1,1\]\]

    Output: 9

    Expected: 9

  ***

  - 案例 C: 多塊島嶼

    Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]

    Output: 6

    Expected: 6

### Solution2(BFS)

- **思路說明**：

  遍歷整個 grid，當遇到陸地時進入 BFS 處理。

  在 BFS 中，使用 queue 來管理待處理的座標，先將起始陸地的座標加入 queue。

  進入 while 迴圈，從 queue 中取出座標，若該座標不合法則跳過處理(continue)，

  若座標合法，則將陸地數量加一，並將當前陸地標記為水域('0')，避免重複計算。

  接著將四個方向(上右下左)的鄰居座標加入 queue。

  當 queue 為空時，代表該島嶼已處理完畢。此時更新最大陸地數量，繼續外層 grid 遍歷。

  已處理過的陸地因為被標記為水域，在後續遍歷中會被跳過，不會重複計算。

  持續遍歷直到處理完所有 cell，最後回傳記錄到的最大陸地數量。

  P.S. 相較於 DFS 使用 stack，BFS 使用 queue 來管理遍歷順序，因為先進先出的特性，使得 BFS 像水波一樣一層一層往外擴散

- **複雜度分析**：

  - 時間複雜度：O(m × n) -> 每個 cell 最多被訪問常數次(外層 grid 遍歷一次 + BFS 內部可能再訪問一次)

  - 空間複雜度：O(min(m, n)) -> queue 的最大長度，最壞情況發生在矩形島嶼時，queue 會儲存整個邊界的座標

  - 通過狀態：✅ AC

- **其他備註\(優化方向、特殊限制、問題延伸討論\)**：

  - 目前實作是透過 queue.shift() 來取出元素。在 JavaScript 中 shift 是 O(n) 操作，

    這會讓整體時間複雜度從理論上的 O(m × n) 退化到實際的 O((m × n)²)。

    - 優化方式：

      1. 使用兩個指針模擬 queue(一個指向讀取位置，一個指向寫入位置)

      2. 使用更高效的 deque 實作

- **測試案例**： 同 Solution1 測試範例

### Solution3(UnionFind)

- **思路說明**：

  UnionFind 的核心概念是「動態連通性」，用來處理「哪些元素屬於同一個集合」的問題。

  對這題來說，同一個島嶼的所有陸地就是同一個集合。

  **為什麼需要將 2D 座標轉換成 1D id？**

  UnionFind 的 parent 和 size 陣列是一維的，所以需要將二維座標 (i, j) 轉換成唯一的一維索引。

  轉換公式：`id = i * col + j`，這樣每個 cell 都有唯一的 id。

  **初始化階段(Constructor)**：

  遍歷整個 grid，只對陸地進行初始化：

  - 將每個陸地的 parent 設為自己(代表一開始每個陸地都是獨立的集合)
  - 將每個陸地的 size 設為 1(初始每個集合只有一個元素)
  - 設定 maxLandCount = 1(至少有一個陸地時才會初始化)

  **合併階段(主函數)**：

  再次遍歷 grid，當遇到陸地時，檢查右邊和下邊的鄰居(只檢查兩個方向即可避免重複合併)：

  - 若右邊也是陸地，將兩者 union
  - 若下邊也是陸地，將兩者 union

  **為什麼 union 時要更新 maxLandCount？**

  當兩個獨立的陸地集合合併時，新集合的大小 = 兩個集合的 size 總和。

  在合併的當下立即更新 maxLandCount，這樣遍歷結束後就能直接取得最大島嶼面積，不需要再遍歷一次 size 陣列。

  **find 方法(路徑壓縮)**：

  遞迴找到根節點的過程中，順便將路徑上所有節點的 parent 都指向根節點。這個優化讓後續的 find 操作接近 O(1)。

  **union 方法(union by size)**：

  將較小的樹接到較大的樹下，避免樹過深。合併時更新較大樹的根的 size，並同步更新 maxLandCount。

- **複雜度分析**：

  - 時間複雜度：O(m × n × α(m × n)) -> 遍歷 grid 是 O(m × n)，每次 union/find 操作接近 O(α(m × n))，α 是 Ackermann 函數的反函數，實際上可視為常數

  - 空間複雜度：O(m × n) -> parent 和 size 陣列都是 O(m × n)

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - **與 DFS/BFS 的比較**：

    - DFS/BFS 適合靜態分析(一次性處理完成)

    - UnionFind 更適合動態場景(陸地逐步增加或減少時，可以動態維護連通性)

    - 對這題來說，DFS/BFS 更直觀簡潔

  - **為什麼只檢查右邊和下邊？**：

    當遍歷到 (i, j) 時，左邊 (i, j-1) 和上邊 (i-1, j) 已經在前面的迭代中處理過了。

    如果它們與當前陸地相連，在處理它們時就已經 union 過了。

    只檢查右邊和下邊可以避免重複的 union 操作。

  - **rank vs size 的關鍵差異**：

    - `rank[i]`：樹的高度（從根到最遠葉子的邊數），初始化為 0

    - `size[i]`：集合的元素個數，初始化為 1

    - **rank 的更新規則**：

      - 不同高度合併：`rank[較高] 不變`（因為最長路徑沒有變長）

      - 相同高度合併：`rank[新根] = 原高度 + 1`（因為最長路徑增加 1）

    - **這題必須用 size**：因為 rank 無法反映集合的元素個數（例如：4 個陸地的島嶼，rank 可能只有 1）

    - **選擇原則**：問「有幾個連通量」用 rank；問「最大連通量的大小」用 size

  - **路徑壓縮的重要性**：

    沒有路徑壓縮時，find 操作可能退化到 O(n)。加上路徑壓縮後，整體效能大幅提升。

  - **實際應用場景**：

    如果題目改成「動態新增陸地，每次新增後查詢當前最大島嶼面積」，

    UnionFind 就會比 DFS/BFS 更高效，因為不需要每次都重新遍歷整個 grid。

- **測試案例**： 同 Solution1 測試範例

## 學習記錄

- 首次解題(DFS)：2025-11-16 | 耗時：不紀錄(重理解思路) | 獨立完成：是
- 首次解題(BFS)：2025-11-16 | 耗時：不紀錄(重理解思路) | 獨立完成：是
- 首次解題(UnionFind)：2025-11-17 | 耗時：不紀錄(重理解思路) | 獨立完成：否。只想出 80% 左右，最後怎麼計算最大陸地數量的邏輯是參考 AI 的
- 複習1：2025-11-20 | 耗時：8分鐘(BFS) | 獨立完成：是 | 順暢度：流暢
