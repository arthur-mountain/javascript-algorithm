---
title: "27. Remove Element"
tags:
  - Array
  - Two Pointers
difficulty: "Easy"
date_solved: "2025-10-26"
link: "https://leetcode.com/problems/remove-element/description/"
---

## 問題描述

給定一個數字陣列 nums 和一個數字 val，原地移除 nums 中所有等於 val 的元素，nums 的順序可能改變。

若有 k 個 elements 不等於 val，那 nums 前 k 個 elements 要不等於 val，最終返回 k（即有 k 個數字不等於 val）。

P.S. 前 k 個 elements 可以是任何順序

## Constraints

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100

## 解題思路

### 初步分析(觀察與發想)

- 暴力解：建立一個處理過的新陣列（排除掉數字等於 val），再更新到原陣列中

  - 會需要額外的 O(n) 空間，以及時間複雜度為 O(n)，因為要遍歷原陣列跟新陣列

- 優化解：使用雙指針，l 跟 r 分別指向陣列頭尾，當 l 指向等於 val 的元素時跟 r 交換，並縮小 r 範圍但 l 不往後走（避免交換過來的元素也等於 val 而漏掉），直到 l > r 為止

## 解法總覽

### Solution1

- **思路說明**：

  建立一個處理過的新陣列，若數字等於 val 則跳過，否則把數字放進新陣列中。

  再遍歷新陣列，一個一個把數字填入原陣列中。因為前方數字的位置沒有任何限制，且後方數字的任何資訊也不重要。

- **複雜度分析**：

  - 時間複雜度：O(n)

  - 空間複雜度：O(n)

  - 通過狀態：✅ AC

- **其他備註(優化方向、特殊限制、問題延伸討論)**：

  - 使用雙指針，只在一次遍歷的情況下，原地更新陣列?

- **測試案例**：

  - 案例 A: 沒有數字

    Input: nums = []; val = 3

    Output: 0, nums = []

    Expected: []

  ***

  - 案例 B: 全部數字都不等於 val

    Input: nums = [1, 2, 4, 5, 6, 7]; val = 3

    Output: 6, nums = [1, 2, 4, 5, 6, 7]

    Expected: [1, 2, 4, 5, 6, 7]

  ***

  - 案例 C: 全部數字都等於 val

    Input: nums = [3,3,3,3,3,3]; val = 3

    Output: 0, nums = [3,3,3,3,3,3]

    Expected: []

  ***

  - 案例 D: 有些數字不等於 val，有些數字等於 val

    Input: nums = [1, 2, 3, 4, 5]; val = 3

    Output: 4, nums = [1, 2, 4, 5, 3]

    Expected: [1, 2, 4, 5]（任意順序）

### Solution2 (最佳解)

- **思路說明**：

  核心概念：把等於 val 的元素往後擺，使用雙指針，l 指向開頭元素遍歷，r 指向最後一個元素。

  當 l 指向的元素等於 val 時跟 r 交換，r 縮小且 l 不往後走(避免交換過來的 r 所指向的元素等於 val 會漏掉)。

  終止條件：當 l <= r 時代表陣列遍歷完畢，即等於 val 的元素都往後擺了。

  最後返回 r + 1 或 l + 1 都可以，代表前幾個元素都是不等於 val 的元素。

  (r + 1 比較直覺，因為核心概念也是在縮小 r 的位置)

  > 因為 l 和 r 不變量代表 index，所以要 +1 才代表長度

- **複雜度分析**：

  - 時間複雜度：O(n)

  - 空間複雜度：O(1)

  - 通過狀態：✅ AC

- **測試案例**：同 solution1

### Solution3 (最佳解2，程式比較乾淨直覺)

- **思路說明**：

  相較於 solution2，同樣是雙指針，這個解法比較直覺。

  l 指針指向當前可以填入有效元素的 index，r 指針往後找不等於 val 的元素。

  若找到不等於 val 的元素，直接無腦把 r 指向的元素覆蓋掉 l 指向的元素，然後 l++。

  最後返回 l，因為 l 所指向的 index 的前面確定都是不等於 val 的元素。

  > 注意：r 一定要初始化為 0 開始，不然會漏掉第一個元素的檢查

- **複雜度分析**：

  - 時間複雜度：O(n)

  - 空間複雜度：O(1)

  - 通過狀態：✅ AC

- **測試案例**：同 solution1

## 學習記錄

- 首次解題：2025-10-26 | 耗時：5分鐘暴力解 | 獨立完成：是
- 首次解題：2025-10-26 | 耗時：20分鐘優化解 | 獨立完成：是
- 複習 1：<!-- 日期 --> | 耗時：分鐘 | 獨立完成：□ 是 □ 否 | 順暢度：□ 流暢 □ 卡頓 □ 忘記
