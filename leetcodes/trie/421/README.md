---
title: "421. Maximum XOR of Two Numbers in an Array"
tags:
  - Array
  - Hash Table
  - Bit Manipulation
  - Trie
difficulty: "Medium"
date_solved: "2025-10-24"
link: "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/"
---

## 問題描述

給予一個正數的 array，回傳任意兩數 XOR 出來的最大值(即 nums[i] XOR nums[j])，且必須符合 0 <= i <= j < n.

## Constraints

- 1 <= nums.length <= 2 \* 10\*\*5
- 0 <= nums[i] <= 2\*\*31 - 1

## 解題思路

### 初步分析

- 關鍵觀察：

  - 兩層迴圈暴力解 O(n\*\*2) 會超時
  - 排序？ 可能還是會需要根暴力解一樣，要找遍所有可能，即使已經排序過
  - set? 知道順序性和重不重複無關，可能幫助不大
  - map? 知道順序性以及 mapping 關係，可能幫助也不大
  - trie? 建立二進制 trie，因為只有 0/1，所以可以使用陣列效率比較高。
    - 前面如果數字一樣 xor 結果會是0，如果數字不一樣xor 出來的結果會是1，因此越前面的數字(高位bit)如果數字不一樣那麼xor出來的值越大
    - 找最大值時，優先相反的值。如果當前數字是 0 就要找 1，反之如果是 1 就要找 0。
      - 如果找到相反的值繼續往下，如果沒能找到，則退一步找當前數字，反正只有 0 和 1 兩種選擇
    - 轉後成後二進制不一樣長度的話高位補 0。但二進制不一樣長怎麼辦？ 怎麼知道高位要補幾個0？
      - 每個數字統一都以 32bits 為二進制，高位補 0

- 適用 Pattern：

  - 建立 binary trie，每個數字都以 32bits 做為二進制表示，高位補 0
  - 找最大值時，優先相反的值。如果當前數字是 0 就要找 1，反之如果是 1 就要找 0。
    - 如果找到相反的值繼續往下，如果沒能找到，則退一步找當前數字，反正只有 0 和 1 兩種選擇

- 可能的陷阱：

  - 數字可以重複嗎？ 如果重複應該不影響，對於 trie 來說不會重複建立，同樣可以找到最大值。且重複的數字 xor 出來會是 0

  - 只有一個數字的話？ xor 自己，可以直接提前返回 0，不用額外建立 trie

## 解法總覽

### Solution1

- **思路說明**：

  1. 建立 binary trie，每個數字都以 32bits 做為二進制表示，高位補 0。

  2. 找數字最大值時，優先找相反的數字來 xor，如果沒有相反的數字，則選擇當前的數字

     - 如果當前數字是 0 就要找 1，反之如果是 1 就要找 0。如果沒能找到，則退一步找當前數字進行 xor。

     - 不用擔心數字沒初始化，因為統一都是 32bits，高位都會補 0

     - 找到最後的bit時，isEndOfBit 一定是 true，因為統一 32bits

- **複雜度分析**：

  - 時間複雜度：O(n) -> 建立 trie + 每個數字 32bits 要走 nums 次，複雜度為 O(n \+ n \* 32)

  - 空間複雜度：O(n) -> 每個數字 32bits，每一個 bit 會建立長度為 2 的陣列，總共 n 次，複雜度為 O(n \* 32 \* 2)

  - 通過狀態：❌ TLE

- **其他備註\(優化方向、特殊限制、問題延伸討論\)**：

  - 目前的 binary 都是透過字串進行計算，如：to32BitsBinary, xors.join("")，導致 TLE。是否有其他方式更高效？

    - A: 使用 BitwWise 操作。參考 solution2

- **測試案例**：

  - 案例 A: sample case

    Input: [3,10,5,25,2,8]

    Output: 28

    Expected: 28

  - 案例 B: sample case

    Input: [14,70,53,83,49,91,36,80,92,51,66,70]

    Output: 127

    Expected: 127

  - 案例 C: 數字中包含重複數字

    Input: [3,10,5,25,2,8, 25]

    Output: 28

    Expected: 28

  - 案例 D: 數字中包含 0

    Input: [3,10,5,25,2,8, 25, 0]

    Output: 28

    Expected: 28

  - 案例 E: 只有一個數字

    Input: [0]

    Output: 0

    Expected: 0

  ***

### Solution2

- **思路說明**：

  同 solution1 的 Trie 架構，但優化以下兩個關鍵操作：

  1. **Insert 階段**：

     - Solution1：先將數字轉為 32 位二進制字串，再逐字元遍歷
     - Solution2：直接使用 `(num >> i) & 1` 逐位提取，從第 31 位到第 0 位

  2. **FindMaxXOR 階段**：

     - Solution1：用陣列收集每一位的 XOR 結果，最後 `parseInt(xors.join(""), 2)` 轉換
     - Solution2：遍歷過程中使用 `(result << 1) | bit` 直接建構結果數字

透過避免字串操作和中間陣列，減少記憶體分配和型別轉換開銷。

- **複雜度分析**：

  - 時間複雜度：O(n \* 32 + n \* 32) -> O(n)

    - 建立 Trie：插入 n 個數字，每個數字需要處理 32 位元 → O(n \* 32)

    - 查找最大 OR：對 n 個數字進行查找，每次查找遍歷 32 位元 → O(n \* 32)

  - 空間複雜度：O(n \* 32) -> O(n)

    - n 個數字，每個數字要建立 32bits 個節點 -> O(n \* 32)

  - 通過狀態：❌ TLE

- **其他備註\(優化方向、特殊限制、問題延伸討論\)**：

  - 位元操作基礎建立

    - 1.1 核心概念：二進制的「位置值」

      先從一個簡單例子開始理解：

      ```plaintext
      數字 25 的二進制是什麼？
      25 = 16 + 8 + 1
         = 2⁴ + 2³ + 2⁰
         = 11001 (二進制)

      位置： 4  3  2  1  0  (從右到左，從 0 開始)
      數值： 1  1  0  0  1
      ```

      **關鍵理解**：每個位置代表 2 的次方，這就是我們操作的「基本單位」。

    - 1.2 必備操作：取得特定位元

      **問題**：如何取得 25 的第 3 位（從右數第 4 個位置）？

      ```javascript
      const num = 25; // 11001

      // 方法：右移 + AND 操作
      const bit3 = (num >> 3) & 1;

      // 拆解步驟：
      // 1. num >> 3  →  將 11001 右移 3 位 → 00011
      // 2. 00011 & 1 →  只保留最右邊一位 → 1
      ```

      **視覺化理解**：

      ```plaintext
      原始:  1 1 0 0 1  (25)
             ↓ ↓ ↓ ↓ ↓
      右移3: 0 0 0 1 1  (25 >> 3 = 3)
             ↓
      &1取:  0 0 0 0 1  (3 & 1 = 1)
      ```

    - 1.3 必備操作：建構數字（邊走邊算）

      這是解決「solution1 findMaxXOR xors.join("")」的核心技巧！

      **情境**：假設我們從左到右遍歷 bits，想建構最終數字

      ```javascript
      // 傳統做法（solution1 的方式）：
      const bits = ["1", "1", "0", "0", "1"];
      const xors = [];
      for (let bit of bits) xors.push(bit);
      const result = parseInt(xors.join(""), 2); // ❌ 需要字串操作

      // 位元操作做法：
      let result = 0;
      for (let bit of [1, 1, 0, 0, 1]) {
        result = (result << 1) | bit; // ✅ 直接計算
      }

      // 過程視覺化：
      // 初始: result = 0 (00000)
      // 第1步: result = (0 << 1) | 1 = 0 | 1 = 1    (00001)
      // 第2步: result = (1 << 1) | 1 = 2 | 1 = 3    (00011)
      // 第3步: result = (3 << 1) | 0 = 6 | 0 = 6    (00110)
      // 第4步: result = (6 << 1) | 0 = 12 | 0 = 12  (01100)
      // 第5步: result = (12 << 1) | 1 = 24 | 1 = 25 (11001)
      ```

      **核心理解**：

      - `<< 1`：將現有數字左移一位（相當於「騰出右邊一個位置」）

      - `| bit`：將新的 bit 填入最右邊

      就像在寫數字：從左到右寫 "25"，實際是 `2*10 + 5`，位元操作也是同樣邏輯！

- **測試案例**：同 solution1 測試範例

  ***

### Solution3

- **思路說明**：

  同 solution2 的 Trie 架構和位元操作優化，但進一步優化節點結構：

  1. **節點結構優化**：

     - Solution2：使用陣列 `children = [null, null]`，需要索引存取
     - Solution3：使用物件屬性 `zero` 和 `one`，直接屬性存取效能更佳

  2. **效能提升原因**：

     - JavaScript 引擎對物件屬性存取有優化（hidden class）
     - 避免陣列索引的邊界檢查和間接尋址
     - 程式碼語意更清晰（`current.zero` vs `current.children[0]`）

  核心演算法保持不變：使用位元操作從高位到低位建立 Trie，查找時優先選擇相反位元以最大化 XOR 結果。

- **複雜度分析**：

  - 時間複雜度：O(n \* 32 + n \* 32) → O(n)

    - 建立 Trie：插入 n 個數字，每個數字需要處理 32 位元 → O(n \* 32)
    - 查找最大 XOR：對 n 個數字進行查找，每次查找遍歷 32 位元 → O(n \* 32)

  - 空間複雜度：O(n \* 32) → O(n)

    - Trie 結構：最壞情況下（所有數字完全不同）需要建立 n \* 32 個節點
    - 實際情況通常更小，因為相同前綴會共享節點路徑

  - 通過狀態：✅ Accepted

- **其他備註（優化方向、特殊限制、問題延伸討論）**：

  - **JavaScript 物件屬性 vs 陣列效能**：

    - V8 引擎對固定結構物件（如只有 `zero` 和 `one` 屬性）使用 hidden class 優化
    - 屬性存取可直接計算記憶體位址，而陣列需要額外的索引運算
    - 對於只有兩個固定子節點的二元 Trie，屬性寫法更符合語意且效能更優

  - **適用場景**：
    - 適合固定分支數（binary trie、ternary tree 等）的樹狀結構
    - 不適合子節點數量動態變化的場景（如一般 Trie，26 個字母）

- **測試案例**：同 solution1 測試範例

## 學習記錄

- 首次解題：2025-10-12 | 耗時：40分鐘 | 獨立完成：否，實作會 TLE，優化方式 Bitwise 有參考解答
- 複習 1：\_\_\_\_ | 順暢度：□ 流暢 □ 卡頓 □ 忘記
