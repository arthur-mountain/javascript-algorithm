# Heap è³‡æ–™çµæ§‹å®Œæ•´æŒ‡å—

> ä¸€å€‹é«˜æ•ˆç‡çš„å„ªå…ˆä½‡åˆ—å¯¦ç¾ï¼Œæ”¯æ´ O(1) å–å¾—æ¥µå€¼ã€O(log n) æ’å…¥èˆ‡åˆªé™¤

## ğŸ“š ç›®éŒ„

1. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
2. [ç‚ºä»€éº¼éœ€è¦ Heap](#ç‚ºä»€éº¼éœ€è¦-heap)
3. [æ·±å±¤ç†è§£ï¼šå…­å¤§æ ¸å¿ƒè¦é»](#æ·±å±¤ç†è§£å…­å¤§æ ¸å¿ƒè¦é»)
4. [Heap vs å…¶ä»–è³‡æ–™çµæ§‹](#heap-vs-å…¶ä»–è³‡æ–™çµæ§‹)
5. [å¯¦ä½œç´°ç¯€](#å¯¦ä½œç´°ç¯€)
6. [å¸¸è¦‹æ‡‰ç”¨å ´æ™¯](#å¸¸è¦‹æ‡‰ç”¨å ´æ™¯)
7. [æ™‚é–“è¤‡é›œåº¦ç¸½çµ](#æ™‚é–“è¤‡é›œåº¦ç¸½çµ)
8. [å¸¸è¦‹é™·é˜±èˆ‡èª¤è§£](#å¸¸è¦‹é™·é˜±èˆ‡èª¤è§£)
9. [é€²éšä¸»é¡Œ](#é€²éšä¸»é¡Œ)

## æ ¸å¿ƒæ¦‚å¿µ

### ä»€éº¼æ˜¯ Heapï¼Ÿ

Heap æ˜¯ä¸€ç¨®**ç‰¹æ®Šçš„å®Œå…¨äºŒå…ƒæ¨¹**ï¼Œæ»¿è¶³ä»¥ä¸‹æ€§è³ªï¼š

- **Max Heap**ï¼šæ¯å€‹çˆ¶ç¯€é»çš„å€¼ **â‰¥** å…¶æ‰€æœ‰å­ç¯€é»çš„å€¼ (æ ¹ç¯€é»æ˜¯æœ€å¤§å€¼)
- **Min Heap**ï¼šæ¯å€‹çˆ¶ç¯€é»çš„å€¼ **â‰¤** å…¶æ‰€æœ‰å­ç¯€é»çš„å€¼ (æ ¹ç¯€é»æ˜¯æœ€å°å€¼)

### è¦–è¦ºåŒ–ç†è§£

```
Max Heap ç¯„ä¾‹ï¼š              Min Heap ç¯„ä¾‹ï¼š
      50                         1
     /  \                       / \
   30    40                    3   2
   / \   / \                  / \ / \
  10 20 15 25                8  7 9  3
```

**é—œéµæ´å¯Ÿ**ï¼š

- Heap **ä¸æ˜¯å®Œå…¨æ’åº**çš„ï¼Œåªä¿è­‰çˆ¶å­é—œä¿‚
- å·¦å³å­ç¯€é»ä¹‹é–“**æ²’æœ‰å¤§å°é—œä¿‚è¦æ±‚** (é€™èˆ‡ BST ä¸åŒï¼)
- é€™ç¨®ã€Œéƒ¨åˆ†æœ‰åºã€çš„è¨­è¨ˆè®“æ“ä½œæ›´é«˜æ•ˆ

## ç‚ºä»€éº¼éœ€è¦ Heapï¼Ÿ

### å•é¡Œå ´æ™¯

ç•¶ä½ éœ€è¦ï¼š

1. **é »ç¹å–å¾—æœ€å¤§/æœ€å°å€¼** (å¦‚å„ªå…ˆä½‡åˆ—)
2. **å‹•æ…‹ç¶­è­·å‰ K å¤§/å°å…ƒç´ **
3. **å¯¦ç¾é«˜æ•ˆçš„æ’åº** (Heap Sort)

### Heap çš„å„ªå‹¢

| æ“ä½œ       | Heap     | æ’åºé™£åˆ— | æœªæ’åºé™£åˆ— |
| ---------- | -------- | -------- | ---------- |
| å–å¾—æ¥µå€¼   | O(1)     | O(1)     | O(n)       |
| æ’å…¥å…ƒç´    | O(log n) | O(n)     | O(1)       |
| åˆªé™¤æ¥µå€¼   | O(log n) | O(n)     | O(n)       |
| ç©ºé–“è¤‡é›œåº¦ | O(1)     | O(1)     | O(1)       |

## æ·±å±¤ç†è§£ï¼šå…­å¤§æ ¸å¿ƒè¦é»

### ğŸ”‘ è¦é» 1ï¼šé™£åˆ—å„²å­˜çµæ§‹çš„å·§å¦™è¨­è¨ˆ

**é—œéµç†è§£**ï¼šHeap ç”¨é™£åˆ—å„²å­˜ï¼Œä½†é‚è¼¯ä¸Šæ˜¯æ¨¹

```
é™£åˆ—: [50, 30, 40, 10, 20, 15, 25]
ç´¢å¼•:   0   1   2   3   4   5   6

æ¨¹ç‹€çµæ§‹ï¼š
      50 (0)
     /  \
   30(1) 40(2)
   / \   / \
 10  20 15 25
 (3) (4)(5)(6)
```

**ç‚ºä»€éº¼é¸æ“‡é™£åˆ—ï¼Ÿ**

- **ç©ºé–“æ•ˆç‡é«˜**ï¼šå®Œå…¨äºŒå…ƒæ¨¹çš„é™£åˆ—åˆ©ç”¨ç‡ 50%-100% (å¹³å‡ 75%)
- **å¿«å–å‹å–„**ï¼šé€£çºŒè¨˜æ†¶é«”å­˜å–ï¼ŒCPU å¿«å–å‘½ä¸­ç‡é«˜
- **ç„¡éœ€æŒ‡æ¨™**ï¼šç¯€çœæ¯å€‹ç¯€é» 16 bytes (64ä½ç³»çµ±ä¸­å…©å€‹æŒ‡æ¨™)

**å››å€‹å¿…èƒŒå…¬å¼** (åŸºæ–¼ç´¢å¼• i)ï¼š

```javascript
çˆ¶ç¯€é»ç´¢å¼•ï¼šMath.floor((i - 1) / 2)

å·¦å­ç¯€é»ç´¢å¼•ï¼š2 * i + 1

å³å­ç¯€é»ç´¢å¼•ï¼š2 * i + 2

æœ€å¾Œä¸€å€‹çˆ¶ç¯€é»ç´¢å¼•ï¼šMath.floor(n / 2) - 1
```

### ğŸ”‘ è¦é» 2ï¼šå­æ¨¹å¿…é ˆéƒ½æ˜¯ Heap (Divide and Conquer)

**æ ¸å¿ƒåŸå‰‡**ï¼šæ•´æ£µæ¨¹æ˜¯ Heap **ä¸”** æ‰€æœ‰å­æ¨¹ä¹Ÿéƒ½æ˜¯ Heap

é€™æ˜¯ Divide and Conquer æ€æƒ³çš„é«”ç¾ï¼š

1. **Divide**ï¼šå°‡æ¨¹åˆ†è§£ç‚ºå°å­æ¨¹
2. **Conquer**ï¼šç¢ºä¿æ¯å€‹å­æ¨¹éƒ½æ»¿è¶³ Heap æ€§è³ª
3. **Combine**ï¼šç•¶æ‰€æœ‰å­æ¨¹éƒ½æ­£ç¢ºæ™‚ï¼Œæ•´é«”è‡ªç„¶æ­£ç¢º

**ç‚ºä»€éº¼é€™å¾ˆé‡è¦ï¼Ÿ**

- Heapify çš„ä¸‰æ–¹æ¯”è¼ƒæ‰æœ‰æ„ç¾© (æ¯”è¼ƒçš„æ˜¯ä¸‰å€‹ã€Œå€åŸŸæœ€å¤§å€¼ã€)
- ç¢ºä¿ O(log n) çš„æ™‚é–“è¤‡é›œåº¦
- é¿å…éºæ¼å…¶ä»–åˆ†æ”¯çš„æ›´å¤§å€¼

**å¯¦éš›ä¾‹å­**ï¼š

```
æ­£ç¢ºçš„ Max Heapï¼š        éŒ¯èª¤çš„çµæ§‹ï¼š
     50                    50
    /  \                  /  \
   30  40                30  40
  / \  / \              / \  / \
 10 20 15 25          45 20 15 25  â† 45 > 30ï¼Œé•åæ€§è³ªï¼
```

### ğŸ”‘ è¦é» 3ï¼šå–å€¼æ“ä½œ (Extract) çš„ç²¾å¦™è¨­è¨ˆ

**æ“ä½œæµç¨‹** (ä»¥ Max Heap ç‚ºä¾‹)ï¼š

1. **å–å‡ºæ ¹ç¯€é»** (æœ€å¤§å€¼)- O(1)
2. **ç”¨æœ€å¾Œä¸€å€‹å…ƒç´ æ›¿æ›æ ¹ç¯€é»** - O(1)
3. **Heapify Down** - O(log n)

**ç‚ºä»€éº¼ç”¨æœ€å¾Œä¸€å€‹å…ƒç´ ï¼Ÿ**

- ä¸ç ´å£å®Œå…¨äºŒå…ƒæ¨¹çš„å½¢ç‹€
- ä¸å½±éŸ¿ã€Œæ‰€æœ‰å­æ¨¹éƒ½æ˜¯ Heapã€çš„æ€§è³ª
- é™£åˆ—æ“ä½œé«˜æ•ˆ (pop æœ€å¾Œä¸€å€‹å…ƒç´ æ˜¯ O(1))

```javascript
extractMax() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const max = this.heap[0];              // å–å‡ºæœ€å¤§å€¼
    this.heap[0] = this.heap.pop();        // æœ€å¾Œå…ƒç´ ç§»åˆ°æ ¹éƒ¨
    this.heapifyDown();                    // å‘ä¸‹èª¿æ•´
    return max;
}
```

### ğŸ”‘ è¦é» 4ï¼šæ’å…¥æ“ä½œ (Insert) çš„å°ç¨±è¨­è¨ˆ

**æ“ä½œæµç¨‹**ï¼š

1. **åœ¨é™£åˆ—æœ«å°¾æ·»åŠ æ–°å…ƒç´ ** - O(1)
2. **Heapify Up (å‘ä¸Šå†’æ³¡)** - O(log n)

**ç‚ºä»€éº¼å¾æœ«å°¾æ’å…¥ï¼Ÿ**

- ä¿æŒå®Œå…¨äºŒå…ƒæ¨¹çš„å½¢ç‹€ (å¾å·¦åˆ°å³å¡«æ»¿)
- é™£åˆ—æ“ä½œé«˜æ•ˆ (push æ˜¯ O(1))
- èˆ‡ Extract æ“ä½œå½¢æˆå„ªé›…å°ç¨±

```javascript
insert(value) {
    this.heap.push(value);      // æ”¾åœ¨æœ€å¾Œ
    this.heapifyUp();           // å‘ä¸Šèª¿æ•´
}
```

**æ’å…¥èˆ‡å–å€¼çš„å°ç¨±æ€§**ï¼š

- Insertï¼š**å…ˆæ”¾ç½®ï¼Œå¾Œå‘ä¸Šèª¿æ•´**
- Extractï¼š**å…ˆç§»é™¤ï¼Œå¾Œå‘ä¸‹èª¿æ•´**

### ğŸ”‘ è¦é» 5ï¼šHeapify çš„å–®è·¯å¾‘èª¿æ•´ç­–ç•¥

**Heapify Down çš„æ ¸å¿ƒé‚è¼¯**ï¼š

```javascript
heapifyDown(index = 0) {
    const leftChild = 2 * index + 1;
    const rightChild = 2 * index + 2;
    let largest = index;

    // ä¸‰æ–¹æ¯”è¼ƒï¼šç•¶å‰ç¯€é» vs å·¦å­ vs å³å­
    if (leftChild < size && heap[leftChild] > heap[largest]) {
        largest = leftChild;
    }
    if (rightChild < size && heap[rightChild] > heap[largest]) {
        largest = rightChild;
    }

    // å¦‚æœéœ€è¦èª¿æ•´ï¼Œç¹¼çºŒå‘ä¸‹
    if (largest !== index) {
        swap(index, largest);
        heapifyDown(largest);  // éæ­¸è™•ç†
    }
}
```

**ç‚ºä»€éº¼åªèª¿æ•´ä¸€æ¢è·¯å¾‘ï¼Ÿ**

- åŸºæ–¼å‰æï¼šé™¤äº†ç•¶å‰ç¯€é»ï¼Œå…¶ä»–å­æ¨¹éƒ½å·²ç¶“æ­£ç¢º heap
- åªéœ€ä¿®å¾©ç•¶å‰ç¯€é»é€ æˆçš„å±€éƒ¨é•è¦
- æ™‚é–“è¤‡é›œåº¦ï¼šO(æ¨¹é«˜) = O(log n)

**å¸¸è¦‹èª¤è§£**ï¼š

âŒ èªç‚ºéœ€è¦æ‰¾åˆ°æ•´å€‹ Heap çš„ç¬¬äºŒå¤§å€¼

âœ… å¯¦éš›åªéœ€æ‰¾åˆ°ç•¶å‰å­æ¨¹çš„å±€éƒ¨æœ€å¤§å€¼ï¼Œå› ç‚ºè™•ç†æ­¥é©Ÿå¦‚ä¸‹ï¼š

1. ä¸‰æ–¹æ¯”è¼ƒï¼ˆå¯¦éš›ä¸Šæ˜¯æ¯”è¼ƒä¸‰å€‹å€åŸŸæœ€å¤§å€¼ï¼‰
2. æ‰¾å‡ºçœŸæ­£çš„æœ€å¤§å€¼
3. å¦‚æœéœ€è¦äº¤æ›ï¼Œåªæœ‰è¢«äº¤æ›çš„è·¯å¾‘å¯èƒ½å‡ºç¾æ–°é•è¦
4. éæ­¸è™•ç†è©²è·¯å¾‘
5. å…¶ä»–è·¯å¾‘ä¿æŒä¸è®Š

### ğŸ”‘ è¦é» 6ï¼šHeap Sort çš„ã€Œå¾å¾Œå¾€å‰ã€ç­–ç•¥

**ç‚ºä»€éº¼å¾å¾Œå¾€å‰éæ­·ï¼Ÿ**

Max Heap æä¾›çš„æ˜¯æœ€å¤§å€¼ï¼Œæˆ‘å€‘è¦å»ºç«‹éå¢åºåˆ—ï¼š

- ç¬¬1æ¬¡å–å‡ºï¼šå…¨é«”æœ€å¤§å€¼ â†’ æ”¾åœ¨ç´¢å¼• n-1 (æœ€å¾Œ)
- ç¬¬2æ¬¡å–å‡ºï¼šæ¬¡å¤§å€¼ â†’ æ”¾åœ¨ç´¢å¼• n-2
- ç¬¬kæ¬¡å–å‡ºï¼šç¬¬kå¤§ â†’ æ”¾åœ¨ç´¢å¼• n-k

**é™£åˆ—çš„é›™é‡èº«ä»½**ï¼š

```
åˆå§‹ï¼š[Heap ä½”ç”¨æ•´å€‹é™£åˆ—                    ]
ç¬¬1æ­¥ï¼š[Heap ç¸®å°        ][å·²æ’åº: 1 å€‹å…ƒç´ ]
ç¬¬2æ­¥ï¼š[Heap æ›´å°    ][å·²æ’åº: 2 å€‹å…ƒç´     ]
...
æœ€çµ‚ï¼š[            å·²æ’åº: å…¨éƒ¨å…ƒç´          ]
```

**å®Œæ•´å¯¦ç¾**ï¼š

```javascript
function heapSort(arr) {
  // éšæ®µ1ï¼šBuild Max Heap - O(n)
  buildMaxHeap(arr);

  // éšæ®µ2ï¼šé€ä¸€æå–æœ€å¤§å€¼ - O(n log n)
  for (let i = arr.length - 1; i > 0; i--) {
    swap(arr, 0, i); // æœ€å¤§å€¼ç§»åˆ°ä½ç½® i
    heapify(arr, 0, i); // é‡æ–°èª¿æ•´ (ç¯„åœç¸®å°ç‚º i)
  }
}
```

**ç‚ºä»€éº¼è¿´åœˆæ¢ä»¶æ˜¯ `i > 0`ï¼Ÿ**

- ç•¶ i = 0 æ™‚ï¼Œåªå‰©ä¸€å€‹å…ƒç´ ï¼Œå·²åœ¨æ­£ç¢ºä½ç½®
- é¿å…ä¸å¿…è¦çš„æ“ä½œ

## Heap vs å…¶ä»–è³‡æ–™çµæ§‹

### Heap vs Binary Search Tree (BST)

| ç‰¹æ€§           | Heap             | BST             |
| -------------- | ---------------- | --------------- |
| **ä¸»è¦ç”¨é€”**   | æ‰¾æ¥µå€¼ã€å„ªå…ˆä½‡åˆ— | æœå°‹ã€ç¯„åœæŸ¥è©¢  |
| **æ’åºæ€§è³ª**   | éƒ¨åˆ†æœ‰åº (å‚ç›´)  | å…¨åŸŸæœ‰åº (æ°´å¹³) |
| **å·¦å³å­ç¯€é»** | ç„¡å¤§å°é—œä¿‚       | å·¦ < æ ¹ < å³    |
| **å–æ¥µå€¼**     | O(1)             | O(log n)        |
| **æ’å…¥**       | O(log n)         | O(log n)        |
| **æœå°‹ä»»æ„å€¼** | O(n)             | O(log n)        |
| **é™£åˆ—å¯¦ç¾**   | å®Œç¾é©é…         | ä¸é©åˆ          |

**ä½•æ™‚é¸æ“‡ Heapï¼Ÿ**

- åªéœ€è¦é »ç¹ç²å–æœ€å¤§/æœ€å°å€¼
- ä¸éœ€è¦æœå°‹ä»»æ„å…ƒç´ 
- éœ€è¦åŸåœ°æ’åº (ç©ºé–“å—é™)

### Heap vs æ’åºé™£åˆ—

**å‹•æ…‹å ´æ™¯å°æ¯”**ï¼š

```javascript
// æƒ…å¢ƒï¼šç¶­è­·å‰ K å¤§å…ƒç´ ï¼ŒæŒçºŒæœ‰æ–°æ•¸æ“šé€²å…¥

// æ–¹æ³•1ï¼šæ’åºé™£åˆ— (ä½æ•ˆ)
function updateTopK_Sorted(arr, newElement) {
  arr.push(newElement);
  arr.sort(); // O(n log n) - å¤ªæ…¢ï¼
  return arr.slice(-k);
}

// æ–¹æ³•2ï¼šMin Heap (é«˜æ•ˆ)
function updateTopK_Heap(heap, newElement) {
  if (heap.size() < k) {
    heap.insert(newElement); // O(log k)
  } else if (newElement > heap.peek()) {
    heap.extractMin(); // O(log k)
    heap.insert(newElement); // O(log k)
  }
  return heap;
}
```

## å¯¦ä½œç´°ç¯€

### å»ºç«‹ Heap çš„å…©ç¨®æ–¹å¼

#### æ–¹æ³•1ï¼šé€ä¸€æ’å…¥ (O(n log n))

```javascript
function buildHeapByInsertion(arr) {
  const heap = new MaxHeap();
  for (let num of arr) {
    heap.insert(num); // æ¯æ¬¡ O(log n)
  }
  return heap;
}
```

#### æ–¹æ³•2ï¼šHeapify (O(n) - æ›´å„ªï¼)

```javascript
function buildMaxHeap(arr) {
  const n = arr.length;
  // å¾æœ€å¾Œä¸€å€‹çˆ¶ç¯€é»é–‹å§‹ï¼Œå‘å‰èª¿æ•´
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapifyDown(arr, i, n);
  }
}
```

**ç‚ºä»€éº¼æ–¹æ³•2æ›´å¿«ï¼Ÿ**

- åº•å±¤ç¯€é»å¤šä½†èª¿æ•´è·é›¢çŸ­
- é ‚å±¤ç¯€é»å°‘ä½†èª¿æ•´è·é›¢é•·
- æ•¸å­¸åˆ†æï¼šç¸½ä»£åƒ¹ = O(n)

**æ•¸å­¸è­‰æ˜ç°¡è¦**ï¼š

```
å±¤æ•¸ | ç¯€é»æ•¸é‡ | æœ€å¤§èª¿æ•´é«˜åº¦ | ä»£åƒ¹
--|----------|--------------|------
h    | 1        | h            | h
h-1  | 2        | h-1          | 2(h-1)
h-2  | 4        | h-2          | 4(h-2)
...
ç¸½ä»£åƒ¹ = Î£(2^i * (h-i)) = O(n)
```

## å¸¸è¦‹æ‡‰ç”¨å ´æ™¯

### 1. å„ªå…ˆä½‡åˆ— (Priority Queue)

```javascript
class PriorityQueue {
  constructor() {
    this.heap = new MaxHeap(); // æˆ– MinHeap
  }

  enqueue(item, priority) {
    this.heap.insert({ item, priority });
  }

  dequeue() {
    return this.heap.extractMax().item;
  }
}

// æ‡‰ç”¨ï¼šä½œæ¥­ç³»çµ±çš„ç¨‹åºèª¿åº¦
```

### 2. æ‰¾ç¬¬ K å¤§å…ƒç´ 

```javascript
function findKthLargest(nums, k) {
  const minHeap = new MinHeap();

  for (let num of nums) {
    minHeap.insert(num);
    if (minHeap.size() > k) {
      minHeap.extractMin(); // ä¿æŒ heap å¤§å°ç‚º k
    }
  }

  return minHeap.peek(); // Heap é ‚éƒ¨å°±æ˜¯ç¬¬ K å¤§
}

// æ™‚é–“ï¼šO(n log k)ï¼Œç©ºé–“ï¼šO(k)
```

### 3. åˆä½µ K å€‹æ’åºé™£åˆ—

```javascript
function mergeKSortedArrays(arrays) {
  const minHeap = new MinHeap();
  const result = [];

  // åˆå§‹åŒ–ï¼šæ¯å€‹é™£åˆ—çš„ç¬¬ä¸€å€‹å…ƒç´ å…¥ heap
  for (let i = 0; i < arrays.length; i++) {
    if (arrays[i].length > 0) {
      minHeap.insert({
        value: arrays[i][0],
        arrayIndex: i,
        elementIndex: 0,
      });
    }
  }

  while (!minHeap.isEmpty()) {
    const { value, arrayIndex, elementIndex } = minHeap.extractMin();
    result.push(value);

    // å¦‚æœè©²é™£åˆ—é‚„æœ‰å…ƒç´ ï¼Œæ”¾å…¥ä¸‹ä¸€å€‹
    if (elementIndex + 1 < arrays[arrayIndex].length) {
      minHeap.insert({
        value: arrays[arrayIndex][elementIndex + 1],
        arrayIndex,
        elementIndex: elementIndex + 1,
      });
    }
  }

  return result;
}
```

### 4. æ•¸æ“šæµä¸­çš„ä¸­ä½æ•¸

```javascript
class MedianFinder {
  constructor() {
    this.maxHeap = new MaxHeap(); // å­˜è¼ƒå°çš„ä¸€åŠ
    this.minHeap = new MinHeap(); // å­˜è¼ƒå¤§çš„ä¸€åŠ
  }

  addNum(num) {
    // ç­–ç•¥ï¼šä¿æŒ maxHeap.size() >= minHeap.size()
    if (this.maxHeap.isEmpty() || num <= this.maxHeap.peek()) {
      this.maxHeap.insert(num);
    } else {
      this.minHeap.insert(num);
    }

    // å¹³è¡¡å…©å€‹ heap
    if (this.maxHeap.size() > this.minHeap.size() + 1) {
      this.minHeap.insert(this.maxHeap.extractMax());
    } else if (this.minHeap.size() > this.maxHeap.size()) {
      this.maxHeap.insert(this.minHeap.extractMin());
    }
  }

  findMedian() {
    if (this.maxHeap.size() > this.minHeap.size()) {
      return this.maxHeap.peek();
    }
    return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
  }
}
```

## æ™‚é–“è¤‡é›œåº¦ç¸½çµ

| æ“ä½œ           | æ™‚é–“è¤‡é›œåº¦ | èªªæ˜                   |
| -------------- | ---------- | ---------------------- |
| **peek()**     | O(1)       | ç›´æ¥è¿”å› heap[0]       |
| **insert()**   | O(log n)   | HeapifyUp æ²¿ä¸€æ¢è·¯å¾‘   |
| **extract()**  | O(log n)   | HeapifyDown æ²¿ä¸€æ¢è·¯å¾‘ |
| **build heap** | O(n)       | ç”±ä¸‹è€Œä¸Šèª¿æ•´           |
| **heap sort**  | O(n log n) | Build + n æ¬¡ Extract   |
| **search()**   | O(n)       | ç„¡åºï¼Œéœ€éæ­·           |

**ç©ºé–“è¤‡é›œåº¦**ï¼šO(1) (åŸåœ°æ“ä½œï¼Œä¸è¨ˆéæ­¸æ£§)

## å¸¸è¦‹é™·é˜±èˆ‡èª¤è§£

### âŒ èª¤è§£1ï¼šHeap æ˜¯å®Œå…¨æ’åºçš„

**éŒ¯èª¤æƒ³æ³•**ï¼š

```
Max Heap: [50, 40, 30, 20, 10]  // å®Œå…¨éæ¸›
```

**å¯¦éš›æƒ…æ³**ï¼š

```
Max Heap: [50, 30, 40, 10, 20]  // åªä¿è­‰çˆ¶ > å­
```

### âŒ èª¤è§£2ï¼šå·¦å­ç¯€é»ä¸€å®šå°æ–¼å³å­ç¯€é»

**åœ¨ BST ä¸­**ï¼šå·¦ < æ ¹ < å³  
**åœ¨ Heap ä¸­**ï¼šå·¦å³å­ç¯€é»ç„¡å¤§å°é—œä¿‚

### âŒ èª¤è§£3ï¼šHeapify éœ€è¦æƒææ•´å€‹ Heap

**éŒ¯èª¤æƒ³æ³•**ï¼šæ‰¾åˆ°çœŸæ­£çš„ç¬¬äºŒå¤§å€¼éœ€è¦éæ­·  
**å¯¦éš›åšæ³•**ï¼šåªéœ€è¦å±€éƒ¨ä¸‰æ–¹æ¯”è¼ƒ

### âŒ èª¤è§£4ï¼šé™£åˆ—è¡¨ç¤ºåªé©ç”¨æ–¼ Heap

**å…¶ä»–æ‡‰ç”¨**ï¼š

- å®Œå…¨äºŒå…ƒæ¨¹éƒ½å¯ä»¥ç”¨é™£åˆ—
- ä½†ç¨€ç–æ¨¹æœƒæµªè²»ç©ºé–“

### âŒ èª¤è§£5ï¼šHeap Sort ä¸€å®šæ¯” Quick Sort æ…¢

**å¯¦éš›æƒ…æ³**ï¼š

- Heap Sortï¼šç©©å®š O(n log n)ï¼ŒåŸåœ°æ’åº
- Quick Sortï¼šå¹³å‡ O(n log n)ï¼Œæœ€å£ O(nÂ²)

**é¸æ“‡ä¾æ“š**ï¼š

- éœ€è¦ç©©å®šæ€§èƒ½ â†’ Heap Sort
- å¹³å‡æ€§èƒ½æœ€å„ª â†’ Quick Sort
- è¨˜æ†¶é«”å—é™ â†’ Heap Sort

## é€²éšä¸»é¡Œ

### 1. ç‚ºä»€éº¼ Build Heap æ˜¯ O(n)ï¼Ÿ

**ç›´è¦ºåˆ†æ**ï¼š

- n å€‹å…ƒç´ ï¼Œæ¯å€‹ heapify æœ€å¤š O(log n)
- ç¸½ä»£åƒ¹æ‡‰è©²æ˜¯ O(n log n)ï¼Ÿ

**å¯¦éš›åˆ†æ**ï¼š

- å¤§éƒ¨åˆ†ç¯€é»åœ¨åº•å±¤ï¼Œèª¿æ•´ä»£åƒ¹å°
- é ‚å±¤ç¯€é»å°‘ï¼Œå³ä½¿èª¿æ•´ä»£åƒ¹å¤§ä¹Ÿå½±éŸ¿æœ‰é™

**åš´æ ¼è­‰æ˜**ï¼š

```
è¨­æ¨¹é«˜ç‚º h
ç¬¬ i å±¤æœ‰ 2^i å€‹ç¯€é»ï¼Œå‘ä¸‹èª¿æ•´æœ€å¤š h-i æ¬¡

ç¸½ä»£åƒ¹ = Î£(i=0 to h) 2^i * (h-i)
       = 2^h * Î£(i=0 to h) (h-i) / 2^i
       â‰¤ 2^h * 2
       = O(n)
```

### 2. è®Šé«” Heap

**d-ary Heap**ï¼š

- æ¯å€‹ç¯€é»æœ‰ d å€‹å­ç¯€é»
- æ’å…¥æ›´å¿« (æ¨¹æ›´çŸ®)ï¼Œåˆªé™¤ç¨æ…¢

**Fibonacci Heap**ï¼š

- æ”¤éŠ·åˆ†æä¸‹æ’å…¥ O(1)
- ç”¨æ–¼ Dijkstra ç­‰åœ–ç®—æ³•

**Binomial Heap**ï¼š

- æ”¯æ´é«˜æ•ˆåˆä½µæ“ä½œ
- ç”¨æ–¼å¯åˆä½µå„ªå…ˆä½‡åˆ—

### 3. Heap åœ¨æ¼”ç®—æ³•ä¸­çš„æ‡‰ç”¨

**Dijkstra æœ€çŸ­è·¯å¾‘**ï¼š

```javascript
function dijkstra(graph, start) {
  const minHeap = new MinHeap();
  const distances = new Map();

  minHeap.insert({ node: start, distance: 0 });

  while (!minHeap.isEmpty()) {
    const { node, distance } = minHeap.extractMin();

    if (distances.has(node)) continue;
    distances.set(node, distance);

    for (let [neighbor, weight] of graph.get(node)) {
      if (!distances.has(neighbor)) {
        minHeap.insert({
          node: neighbor,
          distance: distance + weight,
        });
      }
    }
  }

  return distances;
}
```

**Huffman ç·¨ç¢¼**ï¼š ä½¿ç”¨ Min Heap æ§‹å»ºæœ€å„ªå‰ç¶´ç·¨ç¢¼æ¨¹

## ç¸½çµ

Heap æ˜¯ä¸€å€‹è¨­è¨ˆç²¾å¦™çš„è³‡æ–™çµæ§‹ï¼Œå®ƒå®Œç¾åœ°å¹³è¡¡äº†ï¼š

- **ç°¡å–®æ€§**ï¼šé™£åˆ—å¯¦ç¾ï¼Œç„¡éœ€è¤‡é›œæŒ‡æ¨™
- **é«˜æ•ˆæ€§**ï¼šO(log n) æ’å…¥åˆªé™¤ï¼ŒO(1) æŸ¥è©¢æ¥µå€¼
- **å¯¦ç”¨æ€§**ï¼šå»£æ³›æ‡‰ç”¨æ–¼å„ªå…ˆä½‡åˆ—ã€æ’åºã€åœ–ç®—æ³•

æŒæ¡ Heap çš„é—œéµåœ¨æ–¼ç†è§£ï¼š

1. **çµæ§‹è¨­è¨ˆ**ï¼šå®Œå…¨äºŒå…ƒæ¨¹ + é™£åˆ—å„²å­˜
2. **æ€§è³ªç¶­è­·**ï¼šæ‰€æœ‰å­æ¨¹éƒ½æ˜¯ Heap
3. **æ“ä½œåŸç†**ï¼šå±€éƒ¨èª¿æ•´é”æˆå…¨åŸŸæ­£ç¢º

è¨˜ä½ï¼šHeap ä¸è¿½æ±‚å®Œç¾æ’åºï¼Œè€Œæ˜¯ç”¨æœ€å°ä»£åƒ¹ç¶­è­·ã€Œæ ¹ç¯€é»æ˜¯æ¥µå€¼ã€é€™ä¸€å€‹é—œéµæ€§è³ªã€‚é€™ç¨®ã€Œå¤ ç”¨å°±å¥½ã€çš„è¨­è¨ˆå“²å­¸ï¼Œæ­£æ˜¯ç®—æ³•è¨­è¨ˆçš„æ™ºæ…§æ‰€åœ¨ã€‚

**æœ€å¾Œçš„æé†’**ï¼š

- å¯¦ä½œæ™‚æ³¨æ„ç´¢å¼•è¶Šç•Œæª¢æŸ¥
- ç†è§£æ™‚é—œæ³¨ divide and conquer æ€æƒ³
- æ‡‰ç”¨æ™‚è€ƒæ…®ç©ºé–“èˆ‡æ™‚é–“çš„æ¬Šè¡¡
