# Union-Find

## 📌 核心定位

Union-Find 專門解決**動態連通性問題**，在「頻繁的合併操作」與「快速的連通性查詢」之間取得最佳平衡。

**典型應用場景**：

- 檢測圖中的連通分量(Connected Components)

- 判斷圖中是否存在環路(Cycle Detection)

- 最小生成樹演算法(Kruskal's Algorithm)

- 動態網路連通性(Network Connectivity)

---

## 🧠 核心概念

Union-Find 透過**父節點映射**維護集合結構。想像一片森林，每棵樹代表一個連通集合，樹根是該集合的代表元素。

### 心智模型

**類比：公司併購網絡**

想像一片商業版圖，每家公司最初都是獨立的。隨著併購發生，形成了複雜的母子公司關係：

| 操作                | 類比                                 | 實際意義                         |
| ------------------- | ------------------------------------ | -------------------------------- |
| `find(x)`           | 追溯某公司的**最終母公司**是誰       | 找到節點所屬集合的代表元素（根） |
| `union(x, y)`       | 兩家公司合併，一家成為另一家的子公司 | 將兩個集合合併為一個             |
| `isConnected(x, y)` | 比較兩家公司的最終母公司是否相同     | 判斷兩節點是否在同一集合         |

**類比的局限性**：

- 真實公司不會「路徑壓縮」 —— 但 Union-Find 會讓所有子公司直接指向最終母公司
- 真實併購有複雜的層級關係 —— Union-Find 只關心「是否同一夥」，不關心層級細節

### 資料結構設計

- **parent 陣列**：`parent[i]` 儲存節點 i 的父節點，根節點滿足 `parent[i] = i`

- **height 陣列**：`height[i]` 記錄以 i 為根的樹的高度(用於優化)

### 初始狀態

每個節點獨自成為一個集合，即 `parent[i] = i`，所有節點都是自己的根。

---

## ⚙️ 核心操作

### 1. Find(查找根節點)

**目的**：找到節點所屬集合的代表元素(根節點)

**基礎實作**：

```javascript
findRoot(id) {
  while (this.parent[id] !== id) {
    id = this.parent[id];  // 沿著父指針向上
  }
  return id;
}
```

**優化：路徑壓縮(Path Compression)**

在查找過程中，將路徑上的所有節點直接連到根節點。這確保後續查詢能在近乎常數時間內完成。

```javascript
findRoot(id) {
  if (this.parent[id] === id) {
    return id;  // 已經是根節點
  }
  // 遞迴查找並壓縮路徑
  return this.parent[id] = this.findRoot(this.parent[id]);
}
```

**視覺化說明**：

```plaintext

查找前(查找節點1)：                                     1 → 2 → 3 → 4(4 是根)

查找後(對於節點1,2,3 的根都是4，所以都直接指向節點4)：  1 → 4
                                                        2 → 4
                                                        3 → 4
                                                        4(根)
因此後續查找節點1,2,3 的根時就已經指到根節點，不用再遞迴查找
```

---

### 2. Union(合併集合)

**目的**：將兩個節點所屬的集合合併為一個

**基礎邏輯**：

1. 找到兩個節點各自的根節點

2. 若根相同，則已連通，無需操作

3. 若根不同，將一個根指向另一個根

**優化：按秩合併(Union by Rank/Height)**

總是將**矮樹接到高樹**下，避免樹退化成鏈表。這需要用 height 陣列追蹤每棵樹的高度。

**高度更新規則**：

| 合併情況       | 高度變化                 | 原因                       |
| -------------- | ------------------------ | -------------------------- |
| 不同高度樹合併 | 新根高度 = max(兩樹高度) | 矮樹接到高樹，最長路徑不變 |
| 相同高度樹合併 | 新根高度 = 原高度 + 1    | 最長路徑增加 1             |

**視覺化範例**：

```plaintext
情況 1：不同高度(矮接高，高度不變)
    3(h=2)       5(h=1)           3(h=2)
   / \          / \        =>  /  |  \
  4   8        4   6          4   8   5
     / \                         / \  / \
    7   9                       7  9 4  6

情況 2：相同高度(任一接另一，高度+1)
    5(h=1)       6(h=1)           5(h=2)
   / \          / \        =>  /  |  \
  4   6        5   8          4   6   6
                                     / \
                                    5   8
```

---

## 📊 複雜度分析

經過路徑壓縮和按秩合併優化後：

| 操作       | 時間複雜度 | 說明                                   |
| ---------- | ---------- | -------------------------------------- |
| Find       | O(α(n))    | α 是反阿克曼函數，實際應用中可視為常數 |
| Union      | O(α(n))    | 包含兩次 Find 操作                     |
| 空間複雜度 | O(n)       | parent 和 height 陣列                  |

**理論背景**：Tarjan 和 van Leeuwen (1984) 證明，結合這兩種優化的 Union-Find，單次操作的均攤時間為 O(α(n))，其中 α(n) < 5 對於所有實際應用場景。

---

## 🎯 實作要點

### 何時更新高度？

- ✅ **需要更新**：相同高度的樹合併時

- ❌ **不需要更新**：不同高度的樹合併時(將矮接高)

### 常見陷阱

1. **忘記路徑壓縮**：導致查詢退化為 O(n)

2. **高度更新錯誤**：在不同高度合併時錯誤增加高度

3. **Union 時未 Find**：直接操作節點而非根節點

---

## 從具體問題到抽象概念的橋樑

### 第一步：識別節點

在這個問題中，什麼東西需要判斷「是否連通」？這些東西就是你的節點。讓我們看幾個例子。

1. 在島嶼問題中，每個陸地格子(值為 1 的位置)是一個節點。你有一個 `m × n` 的矩陣，所以最多有 `m × n` 個潛在節點。

   因此你創建 `new UnionFind(m * n)`。即使有些位置是水(值為 0)，我們也先分配空間，之後只對陸地格子進行 union 操作。

2. 在朋友圈問題(LeetCode 547)中，每個人是一個節點。如果有 n 個人，你就創建 `new UnionFind(n)`。

   這裡節點已經被題目明確定義了，不需要額外轉換。

3. 在冗餘連接問題(LeetCode 684)中，節點就是圖中的頂點。

   題目告訴你有 n 個節點，而且節點編號從 1 開始，所以你創建 `new UnionFind(n + 1)`，把索引 0 留空不用。

### 第二步：建立 ID 映射

如何用一個整數唯一標識每個節點？這個整數就是你傳給 `findRoot()` 和 `union()` 的參數。

1. 對於矩陣問題，可以把二維座標 `(row, col)` 轉換成一維索引。標準公式是 `id = row * 總列數 + col`。

   這個公式的直覺是：把矩陣的每一行首尾相接排成一條線。比如一個 3×4 的矩陣，位置 `(1, 2)` 會被映射到 `1 * 4 + 2 = 6`。

   可以在紙上畫個小矩陣，標上 0 到 11 的編號，感受一下這個映射。

2. 對於已經有編號的節點(像圖問題)，直接使用題目給的編號即可。

   唯一要注意的是編號起點：如果從 0 開始就直接用，如果從 1 開始就要思考是否需要 `size + 1` 來容納所有編號。

### 第三步：確定連接條件

什麼時候兩個節點應該 union 起來？這決定了你在什麼地方調用 `uf.union(x, y)`。

1. 在島嶼問題中，當一個陸地格子的上下左右鄰居也是陸地時，你就把它們 union 起來。

   所以會遍歷整個矩陣，對每個陸地格子檢查它的四個方向。

2. 在冗餘連接問題中，題目給你一系列邊 `[u, v]`，每條邊意味著「節點 u 和節點 v 應該連通」。

   按順序處理這些邊，如果在 union 之前發現 `isConnected(u, v)` 已經是 true，這條邊就是冗餘的。

3. 在朋友圈問題中，鄰接矩陣 `matrix[i][j] === 1` 表示「人 i 和人 j 是朋友」，

   所以遍歷矩陣的上三角(避免重複)，對所有值為 1 的位置執行 `uf.union(i, j)`。

---

## 💡 擴展思考

### 進階優化：按大小合併

除了按高度，也可以按集合大小合併(將小集合接到大集合)：

```javascript
this.size = new Array(size).fill(1);  // 記錄集合大小
union(x, y) {
  let rootX = this.findRoot(x);
  let rootY = this.findRoot(y);

  if (rootX === rootY) return;

  if (this.size[rootX] < this.size[rootY]) {
    this.parent[rootX] = rootY;
    this.size[rootY] += this.size[rootX];
  } else {
    this.parent[rootY] = rootX;
    this.size[rootX] += this.size[rootY];
  }
}
```

這種方法在某些場景下更直觀(例如需要知道集合大小時)。
