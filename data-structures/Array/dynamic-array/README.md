# Dynamic Array

## 🎯 設計理念

核心原則是「先抽象、後具體」：在做任何題目之前，先理解工具的本質，建立從「問題特徵」到「工具選擇」的映射能力。

### 存在意義

**痛點**：Static Array 的容量在建立時就固定了。當我們不確定需要存多少元素時，會面臨兩難：容量設太小會溢出、設太大會浪費記憶體。而且每次「手動擴容」都需要 O(n) 時間複製所有元素，使用上非常不便。

**價值主張**：在保持 O(1) 隨機存取的同時，提供「自動擴縮容」的能力，讓使用者不需要關心容量管理，且 `push` 操作的**攤銷時間複雜度**為 O(1)。

**一句話本質**：會自動「搬家」的 Static Array——空間不夠就搬到更大的房子，搬家成本透過巧妙的擴容策略被攤銷掉。

### 心智模型

延續 Static Array 的「停車場」類比：

**類比：可擴建的智慧停車場**

想像一個有自動化管理系統的停車場：

- **初始狀態**：停車場有 4 個車位，目前停了 0 輛車
- **Push（停車）**：有車進來，管理系統安排到下一個空位
- **自動擴容**：當車位全滿時，系統會自動蓋一個**兩倍大**的新停車場，把所有車搬過去，然後拆掉舊的
- **為什麼要兩倍？**：如果每次只多蓋 1 個車位，停 n 輛車需要搬家 n 次；兩倍策略讓搬家頻率大幅降低

**局限**：

- 真實停車場不會真的「拆掉重蓋」，但記憶體分配就是這樣運作的
- 擴容時有瞬間的 O(n) 成本，在極端即時系統中可能是問題

---

## 🏗️ 抽象結構

### 核心組件

| 組件                | 功能                     | 與 Static Array 的差異     |
| ------------------- | ------------------------ | -------------------------- |
| **data**            | 底層連續記憶體區塊       | 相同（繼承自 StaticArray） |
| **capacity**        | 當前可容納的最大元素數量 | **會動態改變**             |
| **length**          | 目前實際儲存的元素數量   | 相同（繼承自 StaticArray） |
| **growthFactor**    | 擴容倍數（通常為 2）     | **新增**                   |
| **initialCapacity** | 初始容量（縮容下限）     | **新增**                   |

### 狀態表示

**底層資料結構**：與 Static Array 相同，是一塊連續記憶體

**初始狀態**：

- `capacity` = 初始容量（通常為 4 或 8）
- `length` = 0
- `data` = 已分配但未使用的記憶體

**關鍵不變量（Invariants）**：

1. **`0 ≤ length ≤ capacity`**：永遠成立
2. **`capacity ≥ initialCapacity`**：不會縮到比初始更小
3. **`data[0..length-1]`**：為有效資料區域

### 核心操作

Dynamic Array 繼承 Static Array 的所有操作（`get`、`set`、`insert`、`delete`），但新增/修改了以下關鍵操作：

---

#### 1. **Push / Append（尾部新增）**

這是 Dynamic Array 最核心的操作，也是攤銷分析的經典案例。

**目的**：在陣列尾部新增一個元素

**輸入/輸出**：`element: T → void`

**不變量**：

- `length` 增加 1
- 所有既有元素位置不變
- 如果觸發擴容，`capacity` 變為原來的 `growthFactor` 倍

**基礎實作（概念版）**：

```javascript
push(element) {
  // Step 1: 檢查是否需要擴容
  if (this.length === this.capacity) {
    this._resize(this.capacity * this.growthFactor);
  }

  // Step 2: 放入元素並更新 length
  this.data[this.length] = element;
  this.length++;
}
```

**關鍵問題：為什麼是 O(1) 攤銷？**

讓我用具體數字說明。假設初始容量為 1，我們連續 push 8 個元素：

| Push 第幾個 | 當時 capacity | 是否擴容 | 擴容成本       | 放入成本 | 總成本 |
| ----------- | ------------- | -------- | -------------- | -------- | ------ |
| 1           | 1             | 否       | 0              | 1        | 1      |
| 2           | 1→2           | **是**   | 1（複製 1 個） | 1        | 2      |
| 3           | 2→4           | **是**   | 2（複製 2 個） | 1        | 3      |
| 4           | 4             | 否       | 0              | 1        | 1      |
| 5           | 4→8           | **是**   | 4（複製 4 個） | 1        | 5      |
| 6           | 8             | 否       | 0              | 1        | 1      |
| 7           | 8             | 否       | 0              | 1        | 1      |
| 8           | 8             | 否       | 0              | 1        | 1      |

**總成本** = 1 + 2 + 3 + 1 + 5 + 1 + 1 + 1 = **15**

**攤銷成本** = 15 / 8 ≈ **1.875** = O(1)

**數學證明**：

對於 n 個 push 操作，擴容發生在第 1, 2, 4, 8, 16, ... 個元素時。

總複製成本 = 1 + 2 + 4 + 8 + ... + n/2 = n - 1 < n

總放入成本 = n

總成本 < 2n，所以攤銷成本 = O(2n/n) = **O(1)**

---

#### 2. **Resize（內部擴縮容操作）**

**目的**：將底層陣列的容量調整為新大小

**輸入/輸出**：`newCapacity: number → void`

**不變量**：

- 所有有效元素 `data[0..length-1]` 被完整保留
- `capacity` 更新為 `newCapacity`

**實作**：

```javascript
_resize(newCapacity) {
  // 前置條件：新容量必須能容納所有現有元素
  if (newCapacity < this.length) {
    throw new Error(`New capacity ${newCapacity} cannot hold ${this.length} elements`);
  }

  // Step 1: 建立新的記憶體區塊
  const newData = new Array(newCapacity);

  // Step 2: 複製所有有效元素（不是 capacity 個，是 length 個！）
  for (let i = 0; i < this.length; i++) {
    newData[i] = this.data[i];
  }

  // Step 3: 替換引用並更新 capacity
  this.data = newData;
  this.capacity = newCapacity;
}
```

**時間複雜度**：O(n)，其中 n = length

---

#### 3. **Pop（尾部移除）**

**目的**：移除並回傳陣列最後一個元素

**輸入/輸出**：`void → element: T`

**不變量**：

- `length` 減少 1
- 如果 `length` 過小，可能觸發縮容

**基礎實作**：

```javascript
pop() {
  if (this.length === 0) {
    throw new Error("Cannot pop from empty array");
  }

  // Step 1: 取出最後一個元素
  const element = this.data[this.length - 1];

  // Step 2: 清理並更新 length
  this.data[this.length - 1] = undefined;  // 幫助 GC
  this.length--;

  // Step 3: 檢查是否需要縮容（策略選擇）
  if (this.length > 0 && this.length <= this.capacity / 4) {
    this._resize(Math.floor(this.capacity / 2));
  }

  return element;
}
```

---

#### 4. **縮容策略詳解：為什麼是 `capacity/4` 觸發、縮到 `capacity/2`？**

這是一個精心設計的策略，目的是**避免抖動（Thrashing）**。

**問題場景：如果用 `capacity/2` 作為觸發閾值會怎樣？**

假設 capacity = 8，我們在邊界反覆操作：

```plaintext
狀態：length=4, capacity=8
↓ pop() → length=3, 觸發縮容 → capacity=4
狀態：length=3, capacity=4
↓ push() → length=4, 觸發擴容 → capacity=8
狀態：length=4, capacity=8
↓ pop() → length=3, 觸發縮容 → capacity=4
... 無限循環，每次操作都是 O(n)！
```

**解決方案：用 `capacity/4` 觸發、縮到 `capacity/2`**

```plaintext
狀態：length=4, capacity=8
↓ pop() → length=3, 不觸發（3 > 8/4=2）
↓ pop() → length=2, 觸發縮容 → capacity=4
狀態：length=2, capacity=4（使用率 50%）
↓ push() → length=3, 不觸發（3 < 4）
↓ push() → length=4, 觸發擴容 → capacity=8
```

**關鍵洞察**：

| 參數         | 值                         | 作用                                   |
| ------------ | -------------------------- | -------------------------------------- |
| **觸發閾值** | `capacity/4`               | 延後縮容時機，提供緩衝空間             |
| **縮容目標** | `capacity/2`               | 縮容後使用率 = 50%，留有餘裕           |
| **緩衝區間** | `[capacity/4, capacity/2]` | 在此區間內，push/pop 都不會觸發 resize |

這樣設計確保：縮容後至少要再 pop 掉一半的元素才會再次縮容，而要擴容則需要 push 到滿。兩個方向都有足夠的緩衝，避免邊界抖動。

---

## ⭐ 抽象化翻譯器

### 識別核心抽象

**Dynamic Array 的核心對象是**：有序元素序列

**它管理的是這些對象之間的什麼關係？**：位置關係（index）與動態增刪

### 建立映射維度

| 維度                     | 要回答的問題                         | 這個答案決定了什麼           |
| ------------------------ | ------------------------------------ | ---------------------------- |
| **維度 1：存取模式**     | 需要隨機存取嗎？還是只需要頭尾操作？ | Array vs LinkedList          |
| **維度 2：大小變化**     | 元素數量是固定的還是會變化？         | Static vs Dynamic            |
| **維度 3：主要操作位置** | 主要在哪裡增刪？頭部？尾部？中間？   | Array vs Deque vs LinkedList |
| **維度 4：空間考量**     | 能接受 ~2x 的空間浪費嗎？            | 是否需要更緊湊的結構         |

### 實戰檢查表

```plaintext
題目：_______________

1. 需要 O(1) 隨機存取嗎？ _______________
2. 元素數量會動態變化嗎？ _______________
3. 主要增刪位置在哪裡？ _______________
4. 對空間效率有嚴格要求嗎？ _______________

如果答案是「是、是、尾部、否」→ Dynamic Array 是好選擇
```

---

## 🔍 觸發器（模式識別）

### 正向觸發器

| 層級         | 特徵                                      | 為什麼這個特徵指向 Dynamic Array |
| ------------ | ----------------------------------------- | -------------------------------- |
| **關鍵字**   | "list", "append", "collect", "accumulate" | 需要動態收集元素                 |
| **結構**     | 需要順序保持 + 頻繁尾部操作               | Dynamic Array 的強項             |
| **目標**     | 收集所有符合條件的元素                    | 預先不知道有多少，需要動態擴容   |
| **操作模式** | 建立 → 批量 push → 一次性處理             | 經典 Dynamic Array 使用模式      |

**一句話觸發規則**：當你需要「收集不確定數量的元素，之後可能需要隨機存取」時，想到 Dynamic Array。

### 反向觸發器

| 陷阱情境                 | 為什麼不適用      | 更好的選擇             |
| ------------------------ | ----------------- | ---------------------- |
| 頻繁在**頭部**插入刪除   | O(n) 移動成本太高 | Deque / LinkedList     |
| 頻繁在**中間**插入刪除   | O(n) 移動成本太高 | LinkedList / Skip List |
| 需要頻繁檢查「是否存在」 | O(n) 線性搜尋     | HashSet                |
| 需要保持排序且頻繁插入   | 維護排序成本高    | BST / Heap             |

### 與類似工具的決策點

```plaintext
「我需要存儲一組元素」
├── 需要 O(1) 隨機存取？
│   ├── 是 → 需要動態大小？
│   │   ├── 是 → Dynamic Array ✓
│   │   └── 否 → Static Array
│   └── 否 → 主要操作位置？
│       ├── 兩端 → Deque
│       ├── 中間頻繁插刪 → LinkedList
│       └── 只需 LIFO/FIFO → Stack / Queue
```

---

## ⚠️ 注意事項

### 常見陷阱

| 陷阱                | 錯誤寫法                         | 正確寫法                        | 為什麼                 |
| ------------------- | -------------------------------- | ------------------------------- | ---------------------- |
| **Resize 複製範圍** | `for (i = 0; i < capacity; i++)` | `for (i = 0; i < length; i++)`  | 只需複製有效元素       |
| **縮容閾值**        | `length <= capacity / 2` 就縮容  | `length <= capacity / 4` 才縮容 | 避免邊界抖動           |
| **空陣列 Pop**      | 不檢查直接 pop                   | 先檢查 `length > 0`             | 防止越界存取           |
| **擴容倍數為 1**    | `resize(capacity + 1)`           | `resize(capacity * 2)`          | 否則 push n 個是 O(n²) |

### 常見變體

| 變體              | 修改內容                                 | 適用場景               |
| ----------------- | ---------------------------------------- | ---------------------- |
| **Ring Buffer**   | 用取模實現循環，避免頭部刪除的 O(n) 移動 | Deque 的底層實作       |
| **Gap Buffer**    | 在游標位置維護一個「空隙」               | 文字編輯器的底層結構   |
| **Tiered Vector** | 多層 array，平衡存取與插入效率           | 需要頻繁中間插入的場景 |

---

## 🔗 與 Static Array 的關鍵差異總結

| 面向            | Static Array         | Dynamic Array        |
| --------------- | -------------------- | -------------------- |
| **容量**        | 固定不變             | 自動擴縮             |
| **Push**        | 可能失敗（滿了就爆） | 永遠成功（自動擴容） |
| **Push 複雜度** | O(1) 或失敗          | O(1) 攤銷            |
| **空間效率**    | 精確控制             | 可能有 ~2-4x 浪費    |
| **使用複雜度**  | 需手動管理容量       | 無腦使用             |
