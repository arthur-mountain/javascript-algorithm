# DP 的核心概念

DP 的核心思想是「**利用過去計算的結果來解決更大的問題**」。

通常，DP 問題需要滿足以下兩個條件：

1. **最優子結構**：即大問題的最優解可以通過小問題的最優解推導出來。

2. **重疊子問題**：即不同的子問題會重複出現，讓我們可以重複利用結果而不用重新計算。

---

### Step 1: 從簡單的問題開始 —— Fibonacci 數列

假設我們要求第 `n` 個 Fibonacci 數，Fibonacci 數的定義是：

- `F(0) = 0, F(1) = 1`

- `F(n) = F(n-1) + F(n-2)`

計算過程如下：

1. 這個問題有**最優子結構**：要求 `F(n)`，我們只需知道 `F(n-1)` 和 `F(n-2)` 的值。

2. 這個問題有**重疊子問題**：我們會多次計算相同的 Fibonacci 值，例如 `F(n-1)` 和 `F(n-2)`。

利用 DP 表格，我們可以避免重複計算，構建一個陣列來記錄每個 Fibonacci 值。

#### DP 表格實現

```javascript
function fibonacci(n) {
  const dp = new Array(n + 1).fill(0);
  dp[0] = 0;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}
```

---

### Step 2: 學習常見的 DP 類型問題

底下是一些經典的 DP 問題，

這些問題有各自的特點和狀態轉移公式，你可以從中學到不同的 DP 模板和解題思維。

1. **最長遞增子序列** (LIS)

2. **最短路徑問題**，例如 Bellman-Ford 或 Floyd-Warshall 算法

3. **0/1 背包問題**

4. **硬幣找零問題**，例如找最小硬幣數量使得總和為指定金額

---

### Step 3: 學習分配問題的 DP 思維

對基本 DP 問題已經熟悉之後，再來看分配問題的 DP。

分配問題的思路其實是基於背包問題的思想，也就是**如何在多個候選方案中選出總和最小的方案**。

你可以先學習「0/1 背包問題」，理解如何根據容量選擇最優解，然後再理解分配問題中的「最優子結構」。

---

### Step 4: 練習和理解

DP 是需要反覆練習才能真正掌握的主題。以下是一些建議：

1. **分解問題**：每次解題時，試著回答以下問題：

   - 狀態是什麼？（`dp[i]` 的含義）

   - 狀態轉移如何進行？（`dp[i]` 和 `dp[i-1]` 或其他狀態的關係）

   - 基礎條件是什麼？（`dp[0]` 的初始值）

2. **從簡單開始，再逐步遞進**：從簡單的問題開始理解每個 DP 狀態的含義，逐步提升到更高難度的問題。

3. **在理解上花時間**：DP 問題不需要記住公式，而是要理解每個步驟。
   每次嘗試自己推導轉移方程，找到更高效的解決方案。

---

### 1. 自頂向下 (Top-Down) 的動態規劃

**Top-Down** 又稱為**記憶化搜索**或**遞歸 + 記憶化**。這種方法的思路是：

- 從問題的最大狀態出發，不斷遞歸解決更小的子問題。

- 每次遞歸到新的子問題時，先查看是否已經計算過這個子問題的結果。
  如果已經計算過，直接取用，避免重複計算。

- 使用一個記憶化表（通常是一個字典或列表）來記錄每個子問題的解。

#### Top-Down 方法的特點

1. **易於理解**：因為它按照問題拆解的思路遞歸，所以在設計狀態轉移時比較直觀。

2. **可能有深度遞歸**：特別是在大數據量的情況下，遞歸層數可能很深，會消耗大量的內存，甚至導致棧溢出。

#### Top-Down 範例 —— Fibonacci 數列

```javascript
function fibonacci(n, memo = {}) {
  if (n in memo) {
    return memo[n];
  }
  if (n <= 1) {
    return n;
  }
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}
```

利用 `memo` 字典來記錄每個計算過的 Fibonacci 值，避免重複計算。

當 `n` 很大時，這種記憶化會大大減少計算量。

---

### 2. 自底向上 (Bottom-Up) 的動態規劃

通過**填表法**來解決問題的一種方法。

它從最小的子問題開始計算，逐步建立到最終結果，這個過程通常不需要遞歸，而是用一個迴圈來解決。

#### Bottom-Up 方法的特點

1. **避免遞歸**：因為是逐步填表，不會遇到深度遞歸的問題。

2. **適合大數據量**：這種方法通常更節省內存，尤其適合需要遍歷大量子問題的情況。

3. **DP 表的填充過程明確**：因為是逐步構建解，所以可以觀察到整個過程中 DP 表的變化。

#### Bottom-Up 範例 —— Fibonacci 數列

仍然以 Fibonacci 數列為例，這次我們用 Bottom-Up 的方法來實現：

```javascript
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }
  const dp = new Array(n + 1).fill(0);
  dp[1] = 1;
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
}
```

這裡的 `dp` 表格是從最小的子問題開始填充，最終得出我們需要的 `dp[n]` 值。

---

### 3. 如何選擇 Top-Down 還是 Bottom-Up？

選擇哪一種方法主要取決於問題的性質和你的需求：

- **Top-Down 適合問題規模不大，且需要簡化實現**。因為它基於遞歸結構，狀態轉移更直觀。

- **Bottom-Up 更適合大規模問題**。它避免了深度遞歸的問題，且通常在實際運行中更高效。

一般來說，**當一個問題的子問題數量有限且重疊較多**時，Bottom-Up 更合適。

---

### 4. 學習 Top-Down 和 Bottom-Up 的步驟

以下是你可以遵循的步驟，逐步加深理解這兩種方法：

#### Step 1：從小問題開始練習

從簡單的 DP 問題開始，

比如 Fibonacci、Climbing Stairs（爬樓梯問題），這些問題都有簡單的 Top-Down 和 Bottom-Up 解法。

#### Step 2：逐步學習更複雜的問題

一旦熟悉了基本概念，可以進一步練習「最長遞增子序列 (LIS)」、「背包問題」等問題，

這些問題能更好地幫助你理解兩種方法的區別。

#### Step 3：實踐並比較兩種方法

對於同一個問題，試著分別用 Top-Down 和 Bottom-Up 寫出兩個版本，觀察它們的執行速度和

內存使用情況。這樣能幫助你具體了解兩者的優缺點。

#### Step 4：尋找模式

許多 DP 問題可以歸類為「分配問題」、「路徑問題」等。

每個類型都有其適合的 Top-Down 或 Bottom-Up 模式，嘗試從中找到共通的規律。

---

### 小結

1. **Top-Down 更直觀**，適合簡單或遞歸思維清晰的問題。

2. **Bottom-Up 更高效**，適合大規模問題。

3. 透過練習、對比和模式歸納，能夠幫助你熟練地運用這兩種 DP 思維。
